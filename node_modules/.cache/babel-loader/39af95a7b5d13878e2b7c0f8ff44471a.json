{"ast":null,"code":"import { normalize_columns_array } from './normalize_columns_array.js';\nimport { CsvError } from './CsvError.js';\nimport { underscore } from '../utils/underscore.js';\n\nconst normalize_options = function (opts) {\n  const options = {}; // Merge with user options\n\n  for (const opt in opts) {\n    options[underscore(opt)] = opts[opt];\n  } // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n\n\n  if (options.encoding === undefined || options.encoding === true) {\n    options.encoding = 'utf8';\n  } else if (options.encoding === null || options.encoding === false) {\n    options.encoding = null;\n  } else if (typeof options.encoding !== 'string' && options.encoding !== null) {\n    throw new CsvError('CSV_INVALID_OPTION_ENCODING', ['Invalid option encoding:', 'encoding must be a string or null to return a buffer,', `got ${JSON.stringify(options.encoding)}`], options);\n  } // Normalize option `bom`\n\n\n  if (options.bom === undefined || options.bom === null || options.bom === false) {\n    options.bom = false;\n  } else if (options.bom !== true) {\n    throw new CsvError('CSV_INVALID_OPTION_BOM', ['Invalid option bom:', 'bom must be true,', `got ${JSON.stringify(options.bom)}`], options);\n  } // Normalize option `cast`\n\n\n  options.cast_function = null;\n\n  if (options.cast === undefined || options.cast === null || options.cast === false || options.cast === '') {\n    options.cast = undefined;\n  } else if (typeof options.cast === 'function') {\n    options.cast_function = options.cast;\n    options.cast = true;\n  } else if (options.cast !== true) {\n    throw new CsvError('CSV_INVALID_OPTION_CAST', ['Invalid option cast:', 'cast must be true or a function,', `got ${JSON.stringify(options.cast)}`], options);\n  } // Normalize option `cast_date`\n\n\n  if (options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === '') {\n    options.cast_date = false;\n  } else if (options.cast_date === true) {\n    options.cast_date = function (value) {\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  } else if (typeof options.cast_date !== 'function') {\n    throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', ['Invalid option cast_date:', 'cast_date must be true or a function,', `got ${JSON.stringify(options.cast_date)}`], options);\n  } // Normalize option `columns`\n\n\n  options.cast_first_line_to_header = null;\n\n  if (options.columns === true) {\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  } else if (typeof options.columns === 'function') {\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  } else if (Array.isArray(options.columns)) {\n    options.columns = normalize_columns_array(options.columns);\n  } else if (options.columns === undefined || options.columns === null || options.columns === false) {\n    options.columns = false;\n  } else {\n    throw new CsvError('CSV_INVALID_OPTION_COLUMNS', ['Invalid option columns:', 'expect an array, a function or true,', `got ${JSON.stringify(options.columns)}`], options);\n  } // Normalize option `group_columns_by_name`\n\n\n  if (options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false) {\n    options.group_columns_by_name = false;\n  } else if (options.group_columns_by_name !== true) {\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', ['Invalid option group_columns_by_name:', 'expect an boolean,', `got ${JSON.stringify(options.group_columns_by_name)}`], options);\n  } else if (options.columns === false) {\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', ['Invalid option group_columns_by_name:', 'the `columns` mode must be activated.'], options);\n  } // Normalize option `comment`\n\n\n  if (options.comment === undefined || options.comment === null || options.comment === false || options.comment === '') {\n    options.comment = null;\n  } else {\n    if (typeof options.comment === 'string') {\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n\n    if (!Buffer.isBuffer(options.comment)) {\n      throw new CsvError('CSV_INVALID_OPTION_COMMENT', ['Invalid option comment:', 'comment must be a buffer or a string,', `got ${JSON.stringify(options.comment)}`], options);\n    }\n  } // Normalize option `delimiter`\n\n\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if (!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n\n  if (options.delimiter.length === 0) {\n    throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);\n  }\n\n  options.delimiter = options.delimiter.map(function (delimiter) {\n    if (delimiter === undefined || delimiter === null || delimiter === false) {\n      return Buffer.from(',', options.encoding);\n    }\n\n    if (typeof delimiter === 'string') {\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n\n    if (!Buffer.isBuffer(delimiter) || delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', ['Invalid option delimiter:', 'delimiter must be a non empty string or buffer or array of string|buffer,', `got ${delimiter_json}`], options);\n    }\n\n    return delimiter;\n  }); // Normalize option `escape`\n\n  if (options.escape === undefined || options.escape === true) {\n    options.escape = Buffer.from('\"', options.encoding);\n  } else if (typeof options.escape === 'string') {\n    options.escape = Buffer.from(options.escape, options.encoding);\n  } else if (options.escape === null || options.escape === false) {\n    options.escape = null;\n  }\n\n  if (options.escape !== null) {\n    if (!Buffer.isBuffer(options.escape)) {\n      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n    }\n  } // Normalize option `from`\n\n\n  if (options.from === undefined || options.from === null) {\n    options.from = 1;\n  } else {\n    if (typeof options.from === 'string' && /\\d+/.test(options.from)) {\n      options.from = parseInt(options.from);\n    }\n\n    if (Number.isInteger(options.from)) {\n      if (options.from < 0) {\n        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n      }\n    } else {\n      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n    }\n  } // Normalize option `from_line`\n\n\n  if (options.from_line === undefined || options.from_line === null) {\n    options.from_line = 1;\n  } else {\n    if (typeof options.from_line === 'string' && /\\d+/.test(options.from_line)) {\n      options.from_line = parseInt(options.from_line);\n    }\n\n    if (Number.isInteger(options.from_line)) {\n      if (options.from_line <= 0) {\n        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n      }\n    } else {\n      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n    }\n  } // Normalize options `ignore_last_delimiters`\n\n\n  if (options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null) {\n    options.ignore_last_delimiters = false;\n  } else if (typeof options.ignore_last_delimiters === 'number') {\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n\n    if (options.ignore_last_delimiters === 0) {\n      options.ignore_last_delimiters = false;\n    }\n  } else if (typeof options.ignore_last_delimiters !== 'boolean') {\n    throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', ['Invalid option `ignore_last_delimiters`:', 'the value must be a boolean value or an integer,', `got ${JSON.stringify(options.ignore_last_delimiters)}`], options);\n  }\n\n  if (options.ignore_last_delimiters === true && options.columns === false) {\n    throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', ['The option `ignore_last_delimiters`', 'requires the activation of the `columns` option'], options);\n  } // Normalize option `info`\n\n\n  if (options.info === undefined || options.info === null || options.info === false) {\n    options.info = false;\n  } else if (options.info !== true) {\n    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n  } // Normalize option `max_record_size`\n\n\n  if (options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false) {\n    options.max_record_size = 0;\n  } else if (Number.isInteger(options.max_record_size) && options.max_record_size >= 0) {// Great, nothing to do\n  } else if (typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)) {\n    options.max_record_size = parseInt(options.max_record_size);\n  } else {\n    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n  } // Normalize option `objname`\n\n\n  if (options.objname === undefined || options.objname === null || options.objname === false) {\n    options.objname = undefined;\n  } else if (Buffer.isBuffer(options.objname)) {\n    if (options.objname.length === 0) {\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n\n    if (options.encoding === null) {// Don't call `toString`, leave objname as a buffer\n    } else {\n      options.objname = options.objname.toString(options.encoding);\n    }\n  } else if (typeof options.objname === 'string') {\n    if (options.objname.length === 0) {\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    } // Great, nothing to do\n\n  } else if (typeof options.objname === 'number') {// if(options.objname.length === 0){\n    //   throw new Error(`Invalid Option: objname must be a non empty string`);\n    // }\n    // Great, nothing to do\n  } else {\n    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n  }\n\n  if (options.objname !== undefined) {\n    if (typeof options.objname === 'number') {\n      if (options.columns !== false) {\n        throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');\n      }\n    } else {\n      // A string or a buffer\n      if (options.columns === false) {\n        throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');\n      }\n    }\n  } // Normalize option `on_record`\n\n\n  if (options.on_record === undefined || options.on_record === null) {\n    options.on_record = undefined;\n  } else if (typeof options.on_record !== 'function') {\n    throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', ['Invalid option `on_record`:', 'expect a function,', `got ${JSON.stringify(options.on_record)}`], options);\n  } // Normalize option `quote`\n\n\n  if (options.quote === null || options.quote === false || options.quote === '') {\n    options.quote = null;\n  } else {\n    if (options.quote === undefined || options.quote === true) {\n      options.quote = Buffer.from('\"', options.encoding);\n    } else if (typeof options.quote === 'string') {\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n\n    if (!Buffer.isBuffer(options.quote)) {\n      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n    }\n  } // Normalize option `raw`\n\n\n  if (options.raw === undefined || options.raw === null || options.raw === false) {\n    options.raw = false;\n  } else if (options.raw !== true) {\n    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n  } // Normalize option `record_delimiter`\n\n\n  if (options.record_delimiter === undefined) {\n    options.record_delimiter = [];\n  } else if (typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)) {\n    if (options.record_delimiter.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a non empty string or buffer,', `got ${JSON.stringify(options.record_delimiter)}`], options);\n    }\n\n    options.record_delimiter = [options.record_delimiter];\n  } else if (!Array.isArray(options.record_delimiter)) {\n    throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a string, a buffer or array of string|buffer,', `got ${JSON.stringify(options.record_delimiter)}`], options);\n  }\n\n  options.record_delimiter = options.record_delimiter.map(function (rd, i) {\n    if (typeof rd !== 'string' && !Buffer.isBuffer(rd)) {\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a string, a buffer or array of string|buffer', `at index ${i},`, `got ${JSON.stringify(rd)}`], options);\n    } else if (rd.length === 0) {\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', ['Invalid option `record_delimiter`:', 'value must be a non empty string or buffer', `at index ${i},`, `got ${JSON.stringify(rd)}`], options);\n    }\n\n    if (typeof rd === 'string') {\n      rd = Buffer.from(rd, options.encoding);\n    }\n\n    return rd;\n  }); // Normalize option `relax_column_count`\n\n  if (typeof options.relax_column_count === 'boolean') {// Great, nothing to do\n  } else if (options.relax_column_count === undefined || options.relax_column_count === null) {\n    options.relax_column_count = false;\n  } else {\n    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n  }\n\n  if (typeof options.relax_column_count_less === 'boolean') {// Great, nothing to do\n  } else if (options.relax_column_count_less === undefined || options.relax_column_count_less === null) {\n    options.relax_column_count_less = false;\n  } else {\n    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n  }\n\n  if (typeof options.relax_column_count_more === 'boolean') {// Great, nothing to do\n  } else if (options.relax_column_count_more === undefined || options.relax_column_count_more === null) {\n    options.relax_column_count_more = false;\n  } else {\n    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n  } // Normalize option `relax_quotes`\n\n\n  if (typeof options.relax_quotes === 'boolean') {// Great, nothing to do\n  } else if (options.relax_quotes === undefined || options.relax_quotes === null) {\n    options.relax_quotes = false;\n  } else {\n    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);\n  } // Normalize option `skip_empty_lines`\n\n\n  if (typeof options.skip_empty_lines === 'boolean') {// Great, nothing to do\n  } else if (options.skip_empty_lines === undefined || options.skip_empty_lines === null) {\n    options.skip_empty_lines = false;\n  } else {\n    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n  } // Normalize option `skip_records_with_empty_values`\n\n\n  if (typeof options.skip_records_with_empty_values === 'boolean') {// Great, nothing to do\n  } else if (options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null) {\n    options.skip_records_with_empty_values = false;\n  } else {\n    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);\n  } // Normalize option `skip_records_with_error`\n\n\n  if (typeof options.skip_records_with_error === 'boolean') {// Great, nothing to do\n  } else if (options.skip_records_with_error === undefined || options.skip_records_with_error === null) {\n    options.skip_records_with_error = false;\n  } else {\n    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);\n  } // Normalize option `rtrim`\n\n\n  if (options.rtrim === undefined || options.rtrim === null || options.rtrim === false) {\n    options.rtrim = false;\n  } else if (options.rtrim !== true) {\n    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n  } // Normalize option `ltrim`\n\n\n  if (options.ltrim === undefined || options.ltrim === null || options.ltrim === false) {\n    options.ltrim = false;\n  } else if (options.ltrim !== true) {\n    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n  } // Normalize option `trim`\n\n\n  if (options.trim === undefined || options.trim === null || options.trim === false) {\n    options.trim = false;\n  } else if (options.trim !== true) {\n    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n  } // Normalize options `trim`, `ltrim` and `rtrim`\n\n\n  if (options.trim === true && opts.ltrim !== false) {\n    options.ltrim = true;\n  } else if (options.ltrim !== true) {\n    options.ltrim = false;\n  }\n\n  if (options.trim === true && opts.rtrim !== false) {\n    options.rtrim = true;\n  } else if (options.rtrim !== true) {\n    options.rtrim = false;\n  } // Normalize option `to`\n\n\n  if (options.to === undefined || options.to === null) {\n    options.to = -1;\n  } else {\n    if (typeof options.to === 'string' && /\\d+/.test(options.to)) {\n      options.to = parseInt(options.to);\n    }\n\n    if (Number.isInteger(options.to)) {\n      if (options.to <= 0) {\n        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n      }\n    } else {\n      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n    }\n  } // Normalize option `to_line`\n\n\n  if (options.to_line === undefined || options.to_line === null) {\n    options.to_line = -1;\n  } else {\n    if (typeof options.to_line === 'string' && /\\d+/.test(options.to_line)) {\n      options.to_line = parseInt(options.to_line);\n    }\n\n    if (Number.isInteger(options.to_line)) {\n      if (options.to_line <= 0) {\n        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n      }\n    } else {\n      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n    }\n  }\n\n  return options;\n};\n\nexport { normalize_options };","map":{"version":3,"names":["normalize_columns_array","CsvError","underscore","normalize_options","opts","options","opt","encoding","undefined","JSON","stringify","bom","cast_function","cast","cast_date","value","date","Date","parse","isNaN","cast_first_line_to_header","columns","Array","isArray","group_columns_by_name","comment","Buffer","from","isBuffer","delimiter_json","delimiter","length","map","escape","Error","test","parseInt","Number","isInteger","from_line","ignore_last_delimiters","Math","floor","info","max_record_size","objname","toString","on_record","quote","raw","record_delimiter","rd","i","relax_column_count","relax_column_count_less","relax_column_count_more","relax_quotes","skip_empty_lines","skip_records_with_empty_values","skip_records_with_error","rtrim","ltrim","trim","to","to_line"],"sources":["/Users/shivamsingh/stocks-application/node_modules/csv-parse/lib/api/normalize_options.js"],"sourcesContent":["\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {CsvError} from './CsvError.js';\nimport {underscore} from '../utils/underscore.js';\n\nconst normalize_options = function(opts){\n  const options = {};\n  // Merge with user options\n  for(const opt in opts){\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n  if(options.encoding === undefined || options.encoding === true){\n    options.encoding = 'utf8';\n  }else if(options.encoding === null || options.encoding === false){\n    options.encoding = null;\n  }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n    throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n      'Invalid option encoding:',\n      'encoding must be a string or null to return a buffer,',\n      `got ${JSON.stringify(options.encoding)}`\n    ], options);\n  }\n  // Normalize option `bom`\n  if(options.bom === undefined || options.bom === null || options.bom === false){\n    options.bom = false;\n  }else if(options.bom !== true){\n    throw new CsvError('CSV_INVALID_OPTION_BOM', [\n      'Invalid option bom:', 'bom must be true,',\n      `got ${JSON.stringify(options.bom)}`\n    ], options);\n  }\n  // Normalize option `cast`\n  options.cast_function = null;\n  if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n    options.cast = undefined;\n  }else if(typeof options.cast === 'function'){\n    options.cast_function = options.cast;\n    options.cast = true;\n  }else if(options.cast !== true){\n    throw new CsvError('CSV_INVALID_OPTION_CAST', [\n      'Invalid option cast:', 'cast must be true or a function,',\n      `got ${JSON.stringify(options.cast)}`\n    ], options);\n  }\n  // Normalize option `cast_date`\n  if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n    options.cast_date = false;\n  }else if(options.cast_date === true){\n    options.cast_date = function(value){\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  }else if (typeof options.cast_date !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n      'Invalid option cast_date:', 'cast_date must be true or a function,',\n      `got ${JSON.stringify(options.cast_date)}`\n    ], options);\n  }\n  // Normalize option `columns`\n  options.cast_first_line_to_header = null;\n  if(options.columns === true){\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  }else if(typeof options.columns === 'function'){\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  }else if(Array.isArray(options.columns)){\n    options.columns = normalize_columns_array(options.columns);\n  }else if(options.columns === undefined || options.columns === null || options.columns === false){\n    options.columns = false;\n  }else{\n    throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n      'Invalid option columns:',\n      'expect an array, a function or true,',\n      `got ${JSON.stringify(options.columns)}`\n    ], options);\n  }\n  // Normalize option `group_columns_by_name`\n  if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){\n    options.group_columns_by_name = false;\n  }else if(options.group_columns_by_name !== true){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'expect an boolean,',\n      `got ${JSON.stringify(options.group_columns_by_name)}`\n    ], options);\n  }else if(options.columns === false){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'the `columns` mode must be activated.'\n    ], options);\n  }\n  // Normalize option `comment`\n  if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n    options.comment = null;\n  }else{\n    if(typeof options.comment === 'string'){\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.comment)){\n      throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n        'Invalid option comment:',\n        'comment must be a buffer or a string,',\n        `got ${JSON.stringify(options.comment)}`\n      ], options);\n    }\n  }\n  // Normalize option `delimiter`\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n  if(options.delimiter.length === 0){\n    throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n      'Invalid option delimiter:',\n      'delimiter must be a non empty string or buffer or array of string|buffer,',\n      `got ${delimiter_json}`\n    ], options);\n  }\n  options.delimiter = options.delimiter.map(function(delimiter){\n    if(delimiter === undefined || delimiter === null || delimiter === false){\n      return Buffer.from(',', options.encoding);\n    }\n    if(typeof delimiter === 'string'){\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n    if(!Buffer.isBuffer(delimiter) || delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options);\n    }\n    return delimiter;\n  });\n  // Normalize option `escape`\n  if(options.escape === undefined || options.escape === true){\n    options.escape = Buffer.from('\"', options.encoding);\n  }else if(typeof options.escape === 'string'){\n    options.escape = Buffer.from(options.escape, options.encoding);\n  }else if (options.escape === null || options.escape === false){\n    options.escape = null;\n  }\n  if(options.escape !== null){\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n    }\n  }\n  // Normalize option `from`\n  if(options.from === undefined || options.from === null){\n    options.from = 1;\n  }else{\n    if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n      options.from = parseInt(options.from);\n    }\n    if(Number.isInteger(options.from)){\n      if(options.from < 0){\n        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n    }\n  }\n  // Normalize option `from_line`\n  if(options.from_line === undefined || options.from_line === null){\n    options.from_line = 1;\n  }else{\n    if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n      options.from_line = parseInt(options.from_line);\n    }\n    if(Number.isInteger(options.from_line)){\n      if(options.from_line <= 0){\n        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n    }\n  }\n  // Normalize options `ignore_last_delimiters`\n  if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n    options.ignore_last_delimiters = false;\n  }else if(typeof options.ignore_last_delimiters === 'number'){\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n    if(options.ignore_last_delimiters === 0){\n      options.ignore_last_delimiters = false;\n    }\n  }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n    throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n      'Invalid option `ignore_last_delimiters`:',\n      'the value must be a boolean value or an integer,',\n      `got ${JSON.stringify(options.ignore_last_delimiters)}`\n    ], options);\n  }\n  if(options.ignore_last_delimiters === true && options.columns === false){\n    throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n      'The option `ignore_last_delimiters`',\n      'requires the activation of the `columns` option'\n    ], options);\n  }\n  // Normalize option `info`\n  if(options.info === undefined || options.info === null || options.info === false){\n    options.info = false;\n  }else if(options.info !== true){\n    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n  }\n  // Normalize option `max_record_size`\n  if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n    options.max_record_size = 0;\n  }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n    // Great, nothing to do\n  }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n    options.max_record_size = parseInt(options.max_record_size);\n  }else{\n    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n  }\n  // Normalize option `objname`\n  if(options.objname === undefined || options.objname === null || options.objname === false){\n    options.objname = undefined;\n  }else if(Buffer.isBuffer(options.objname)){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n    if(options.encoding === null){\n      // Don't call `toString`, leave objname as a buffer\n    }else{\n      options.objname = options.objname.toString(options.encoding);\n    }\n  }else if(typeof options.objname === 'string'){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    }\n    // Great, nothing to do\n  }else if(typeof options.objname === 'number'){\n    // if(options.objname.length === 0){\n    //   throw new Error(`Invalid Option: objname must be a non empty string`);\n    // }\n    // Great, nothing to do\n  }else{\n    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n  }\n  if(options.objname !== undefined){\n    if(typeof options.objname === 'number'){\n      if(options.columns !== false){\n        throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');\n      }\n    }else{ // A string or a buffer\n      if(options.columns === false){\n        throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');\n      }\n    }\n  }\n  // Normalize option `on_record`\n  if(options.on_record === undefined || options.on_record === null){\n    options.on_record = undefined;\n  }else if(typeof options.on_record !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n      'Invalid option `on_record`:',\n      'expect a function,',\n      `got ${JSON.stringify(options.on_record)}`\n    ], options);\n  }\n  // Normalize option `quote`\n  if(options.quote === null || options.quote === false || options.quote === ''){\n    options.quote = null;\n  }else{\n    if(options.quote === undefined || options.quote === true){\n      options.quote = Buffer.from('\"', options.encoding);\n    }else if(typeof options.quote === 'string'){\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.quote)){\n      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n    }\n  }\n  // Normalize option `raw`\n  if(options.raw === undefined || options.raw === null || options.raw === false){\n    options.raw = false;\n  }else if(options.raw !== true){\n    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n  }\n  // Normalize option `record_delimiter`\n  if(options.record_delimiter === undefined){\n    options.record_delimiter = [];\n  }else if(typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)){\n    if(options.record_delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer,',\n        `got ${JSON.stringify(options.record_delimiter)}`\n      ], options);\n    }\n    options.record_delimiter = [options.record_delimiter];\n  }else if(!Array.isArray(options.record_delimiter)){\n    throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n      'Invalid option `record_delimiter`:',\n      'value must be a string, a buffer or array of string|buffer,',\n      `got ${JSON.stringify(options.record_delimiter)}`\n    ], options);\n  }\n  options.record_delimiter = options.record_delimiter.map(function(rd, i){\n    if(typeof rd !== 'string' && ! Buffer.isBuffer(rd)){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a string, a buffer or array of string|buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }else if(rd.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }\n    if(typeof rd === 'string'){\n      rd = Buffer.from(rd, options.encoding);\n    }\n    return rd;\n  });\n  // Normalize option `relax_column_count`\n  if(typeof options.relax_column_count === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n    options.relax_column_count = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n  }\n  if(typeof options.relax_column_count_less === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n    options.relax_column_count_less = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n  }\n  if(typeof options.relax_column_count_more === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n    options.relax_column_count_more = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n  }\n  // Normalize option `relax_quotes`\n  if(typeof options.relax_quotes === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_quotes === undefined || options.relax_quotes === null){\n    options.relax_quotes = false;\n  }else{\n    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);\n  }\n  // Normalize option `skip_empty_lines`\n  if(typeof options.skip_empty_lines === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n    options.skip_empty_lines = false;\n  }else{\n    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n  }\n  // Normalize option `skip_records_with_empty_values`\n  if(typeof options.skip_records_with_empty_values === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){\n    options.skip_records_with_empty_values = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);\n  }\n  // Normalize option `skip_records_with_error`\n  if(typeof options.skip_records_with_error === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){\n    options.skip_records_with_error = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);\n  }\n  // Normalize option `rtrim`\n  if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n    options.rtrim = false;\n  }else if(options.rtrim !== true){\n    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n  }\n  // Normalize option `ltrim`\n  if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n    options.ltrim = false;\n  }else if(options.ltrim !== true){\n    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n  }\n  // Normalize option `trim`\n  if(options.trim === undefined || options.trim === null || options.trim === false){\n    options.trim = false;\n  }else if(options.trim !== true){\n    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n  }\n  // Normalize options `trim`, `ltrim` and `rtrim`\n  if(options.trim === true && opts.ltrim !== false){\n    options.ltrim = true;\n  }else if(options.ltrim !== true){\n    options.ltrim = false;\n  }\n  if(options.trim === true && opts.rtrim !== false){\n    options.rtrim = true;\n  }else if(options.rtrim !== true){\n    options.rtrim = false;\n  }\n  // Normalize option `to`\n  if(options.to === undefined || options.to === null){\n    options.to = -1;\n  }else{\n    if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n      options.to = parseInt(options.to);\n    }\n    if(Number.isInteger(options.to)){\n      if(options.to <= 0){\n        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n    }\n  }\n  // Normalize option `to_line`\n  if(options.to_line === undefined || options.to_line === null){\n    options.to_line = -1;\n  }else{\n    if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n      options.to_line = parseInt(options.to_line);\n    }\n    if(Number.isInteger(options.to_line)){\n      if(options.to_line <= 0){\n        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n    }\n  }\n  return options;\n};\n\nexport {normalize_options};\n"],"mappings":"AACA,SAAQA,uBAAR,QAAsC,8BAAtC;AACA,SAAQC,QAAR,QAAuB,eAAvB;AACA,SAAQC,UAAR,QAAyB,wBAAzB;;AAEA,MAAMC,iBAAiB,GAAG,UAASC,IAAT,EAAc;EACtC,MAAMC,OAAO,GAAG,EAAhB,CADsC,CAEtC;;EACA,KAAI,MAAMC,GAAV,IAAiBF,IAAjB,EAAsB;IACpBC,OAAO,CAACH,UAAU,CAACI,GAAD,CAAX,CAAP,GAA2BF,IAAI,CAACE,GAAD,CAA/B;EACD,CALqC,CAMtC;EACA;EACA;;;EACA,IAAGD,OAAO,CAACE,QAAR,KAAqBC,SAArB,IAAkCH,OAAO,CAACE,QAAR,KAAqB,IAA1D,EAA+D;IAC7DF,OAAO,CAACE,QAAR,GAAmB,MAAnB;EACD,CAFD,MAEM,IAAGF,OAAO,CAACE,QAAR,KAAqB,IAArB,IAA6BF,OAAO,CAACE,QAAR,KAAqB,KAArD,EAA2D;IAC/DF,OAAO,CAACE,QAAR,GAAmB,IAAnB;EACD,CAFK,MAEA,IAAG,OAAOF,OAAO,CAACE,QAAf,KAA4B,QAA5B,IAAwCF,OAAO,CAACE,QAAR,KAAqB,IAAhE,EAAqE;IACzE,MAAM,IAAIN,QAAJ,CAAa,6BAAb,EAA4C,CAChD,0BADgD,EAEhD,uDAFgD,EAG/C,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACE,QAAvB,CAAiC,EAHQ,CAA5C,EAIHF,OAJG,CAAN;EAKD,CAnBqC,CAoBtC;;;EACA,IAAGA,OAAO,CAACM,GAAR,KAAgBH,SAAhB,IAA6BH,OAAO,CAACM,GAAR,KAAgB,IAA7C,IAAqDN,OAAO,CAACM,GAAR,KAAgB,KAAxE,EAA8E;IAC5EN,OAAO,CAACM,GAAR,GAAc,KAAd;EACD,CAFD,MAEM,IAAGN,OAAO,CAACM,GAAR,KAAgB,IAAnB,EAAwB;IAC5B,MAAM,IAAIV,QAAJ,CAAa,wBAAb,EAAuC,CAC3C,qBAD2C,EACpB,mBADoB,EAE1C,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACM,GAAvB,CAA4B,EAFQ,CAAvC,EAGHN,OAHG,CAAN;EAID,CA5BqC,CA6BtC;;;EACAA,OAAO,CAACO,aAAR,GAAwB,IAAxB;;EACA,IAAGP,OAAO,CAACQ,IAAR,KAAiBL,SAAjB,IAA8BH,OAAO,CAACQ,IAAR,KAAiB,IAA/C,IAAuDR,OAAO,CAACQ,IAAR,KAAiB,KAAxE,IAAiFR,OAAO,CAACQ,IAAR,KAAiB,EAArG,EAAwG;IACtGR,OAAO,CAACQ,IAAR,GAAeL,SAAf;EACD,CAFD,MAEM,IAAG,OAAOH,OAAO,CAACQ,IAAf,KAAwB,UAA3B,EAAsC;IAC1CR,OAAO,CAACO,aAAR,GAAwBP,OAAO,CAACQ,IAAhC;IACAR,OAAO,CAACQ,IAAR,GAAe,IAAf;EACD,CAHK,MAGA,IAAGR,OAAO,CAACQ,IAAR,KAAiB,IAApB,EAAyB;IAC7B,MAAM,IAAIZ,QAAJ,CAAa,yBAAb,EAAwC,CAC5C,sBAD4C,EACpB,kCADoB,EAE3C,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACQ,IAAvB,CAA6B,EAFQ,CAAxC,EAGHR,OAHG,CAAN;EAID,CAzCqC,CA0CtC;;;EACA,IAAGA,OAAO,CAACS,SAAR,KAAsBN,SAAtB,IAAmCH,OAAO,CAACS,SAAR,KAAsB,IAAzD,IAAiET,OAAO,CAACS,SAAR,KAAsB,KAAvF,IAAgGT,OAAO,CAACS,SAAR,KAAsB,EAAzH,EAA4H;IAC1HT,OAAO,CAACS,SAAR,GAAoB,KAApB;EACD,CAFD,MAEM,IAAGT,OAAO,CAACS,SAAR,KAAsB,IAAzB,EAA8B;IAClCT,OAAO,CAACS,SAAR,GAAoB,UAASC,KAAT,EAAe;MACjC,MAAMC,IAAI,GAAGC,IAAI,CAACC,KAAL,CAAWH,KAAX,CAAb;MACA,OAAO,CAACI,KAAK,CAACH,IAAD,CAAN,GAAe,IAAIC,IAAJ,CAASD,IAAT,CAAf,GAAgCD,KAAvC;IACD,CAHD;EAID,CALK,MAKA,IAAI,OAAOV,OAAO,CAACS,SAAf,KAA6B,UAAjC,EAA4C;IAChD,MAAM,IAAIb,QAAJ,CAAa,8BAAb,EAA6C,CACjD,2BADiD,EACpB,uCADoB,EAEhD,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACS,SAAvB,CAAkC,EAFQ,CAA7C,EAGHT,OAHG,CAAN;EAID,CAvDqC,CAwDtC;;;EACAA,OAAO,CAACe,yBAAR,GAAoC,IAApC;;EACA,IAAGf,OAAO,CAACgB,OAAR,KAAoB,IAAvB,EAA4B;IAC1B;IACAhB,OAAO,CAACe,yBAAR,GAAoCZ,SAApC;EACD,CAHD,MAGM,IAAG,OAAOH,OAAO,CAACgB,OAAf,KAA2B,UAA9B,EAAyC;IAC7ChB,OAAO,CAACe,yBAAR,GAAoCf,OAAO,CAACgB,OAA5C;IACAhB,OAAO,CAACgB,OAAR,GAAkB,IAAlB;EACD,CAHK,MAGA,IAAGC,KAAK,CAACC,OAAN,CAAclB,OAAO,CAACgB,OAAtB,CAAH,EAAkC;IACtChB,OAAO,CAACgB,OAAR,GAAkBrB,uBAAuB,CAACK,OAAO,CAACgB,OAAT,CAAzC;EACD,CAFK,MAEA,IAAGhB,OAAO,CAACgB,OAAR,KAAoBb,SAApB,IAAiCH,OAAO,CAACgB,OAAR,KAAoB,IAArD,IAA6DhB,OAAO,CAACgB,OAAR,KAAoB,KAApF,EAA0F;IAC9FhB,OAAO,CAACgB,OAAR,GAAkB,KAAlB;EACD,CAFK,MAED;IACH,MAAM,IAAIpB,QAAJ,CAAa,4BAAb,EAA2C,CAC/C,yBAD+C,EAE/C,sCAF+C,EAG9C,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACgB,OAAvB,CAAgC,EAHQ,CAA3C,EAIHhB,OAJG,CAAN;EAKD,CA1EqC,CA2EtC;;;EACA,IAAGA,OAAO,CAACmB,qBAAR,KAAkChB,SAAlC,IAA+CH,OAAO,CAACmB,qBAAR,KAAkC,IAAjF,IAAyFnB,OAAO,CAACmB,qBAAR,KAAkC,KAA9H,EAAoI;IAClInB,OAAO,CAACmB,qBAAR,GAAgC,KAAhC;EACD,CAFD,MAEM,IAAGnB,OAAO,CAACmB,qBAAR,KAAkC,IAArC,EAA0C;IAC9C,MAAM,IAAIvB,QAAJ,CAAa,0CAAb,EAAyD,CAC7D,uCAD6D,EAE7D,oBAF6D,EAG5D,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACmB,qBAAvB,CAA8C,EAHQ,CAAzD,EAIHnB,OAJG,CAAN;EAKD,CANK,MAMA,IAAGA,OAAO,CAACgB,OAAR,KAAoB,KAAvB,EAA6B;IACjC,MAAM,IAAIpB,QAAJ,CAAa,0CAAb,EAAyD,CAC7D,uCAD6D,EAE7D,uCAF6D,CAAzD,EAGHI,OAHG,CAAN;EAID,CAzFqC,CA0FtC;;;EACA,IAAGA,OAAO,CAACoB,OAAR,KAAoBjB,SAApB,IAAiCH,OAAO,CAACoB,OAAR,KAAoB,IAArD,IAA6DpB,OAAO,CAACoB,OAAR,KAAoB,KAAjF,IAA0FpB,OAAO,CAACoB,OAAR,KAAoB,EAAjH,EAAoH;IAClHpB,OAAO,CAACoB,OAAR,GAAkB,IAAlB;EACD,CAFD,MAEK;IACH,IAAG,OAAOpB,OAAO,CAACoB,OAAf,KAA2B,QAA9B,EAAuC;MACrCpB,OAAO,CAACoB,OAAR,GAAkBC,MAAM,CAACC,IAAP,CAAYtB,OAAO,CAACoB,OAApB,EAA6BpB,OAAO,CAACE,QAArC,CAAlB;IACD;;IACD,IAAG,CAACmB,MAAM,CAACE,QAAP,CAAgBvB,OAAO,CAACoB,OAAxB,CAAJ,EAAqC;MACnC,MAAM,IAAIxB,QAAJ,CAAa,4BAAb,EAA2C,CAC/C,yBAD+C,EAE/C,uCAF+C,EAG9C,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACoB,OAAvB,CAAgC,EAHQ,CAA3C,EAIHpB,OAJG,CAAN;IAKD;EACF,CAxGqC,CAyGtC;;;EACA,MAAMwB,cAAc,GAAGpB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACyB,SAAvB,CAAvB;EACA,IAAG,CAACR,KAAK,CAACC,OAAN,CAAclB,OAAO,CAACyB,SAAtB,CAAJ,EAAsCzB,OAAO,CAACyB,SAAR,GAAoB,CAACzB,OAAO,CAACyB,SAAT,CAApB;;EACtC,IAAGzB,OAAO,CAACyB,SAAR,CAAkBC,MAAlB,KAA6B,CAAhC,EAAkC;IAChC,MAAM,IAAI9B,QAAJ,CAAa,8BAAb,EAA6C,CACjD,2BADiD,EAEjD,2EAFiD,EAGhD,OAAM4B,cAAe,EAH2B,CAA7C,EAIHxB,OAJG,CAAN;EAKD;;EACDA,OAAO,CAACyB,SAAR,GAAoBzB,OAAO,CAACyB,SAAR,CAAkBE,GAAlB,CAAsB,UAASF,SAAT,EAAmB;IAC3D,IAAGA,SAAS,KAAKtB,SAAd,IAA2BsB,SAAS,KAAK,IAAzC,IAAiDA,SAAS,KAAK,KAAlE,EAAwE;MACtE,OAAOJ,MAAM,CAACC,IAAP,CAAY,GAAZ,EAAiBtB,OAAO,CAACE,QAAzB,CAAP;IACD;;IACD,IAAG,OAAOuB,SAAP,KAAqB,QAAxB,EAAiC;MAC/BA,SAAS,GAAGJ,MAAM,CAACC,IAAP,CAAYG,SAAZ,EAAuBzB,OAAO,CAACE,QAA/B,CAAZ;IACD;;IACD,IAAG,CAACmB,MAAM,CAACE,QAAP,CAAgBE,SAAhB,CAAD,IAA+BA,SAAS,CAACC,MAAV,KAAqB,CAAvD,EAAyD;MACvD,MAAM,IAAI9B,QAAJ,CAAa,8BAAb,EAA6C,CACjD,2BADiD,EAEjD,2EAFiD,EAGhD,OAAM4B,cAAe,EAH2B,CAA7C,EAIHxB,OAJG,CAAN;IAKD;;IACD,OAAOyB,SAAP;EACD,CAfmB,CAApB,CAnHsC,CAmItC;;EACA,IAAGzB,OAAO,CAAC4B,MAAR,KAAmBzB,SAAnB,IAAgCH,OAAO,CAAC4B,MAAR,KAAmB,IAAtD,EAA2D;IACzD5B,OAAO,CAAC4B,MAAR,GAAiBP,MAAM,CAACC,IAAP,CAAY,GAAZ,EAAiBtB,OAAO,CAACE,QAAzB,CAAjB;EACD,CAFD,MAEM,IAAG,OAAOF,OAAO,CAAC4B,MAAf,KAA0B,QAA7B,EAAsC;IAC1C5B,OAAO,CAAC4B,MAAR,GAAiBP,MAAM,CAACC,IAAP,CAAYtB,OAAO,CAAC4B,MAApB,EAA4B5B,OAAO,CAACE,QAApC,CAAjB;EACD,CAFK,MAEA,IAAIF,OAAO,CAAC4B,MAAR,KAAmB,IAAnB,IAA2B5B,OAAO,CAAC4B,MAAR,KAAmB,KAAlD,EAAwD;IAC5D5B,OAAO,CAAC4B,MAAR,GAAiB,IAAjB;EACD;;EACD,IAAG5B,OAAO,CAAC4B,MAAR,KAAmB,IAAtB,EAA2B;IACzB,IAAG,CAACP,MAAM,CAACE,QAAP,CAAgBvB,OAAO,CAAC4B,MAAxB,CAAJ,EAAoC;MAClC,MAAM,IAAIC,KAAJ,CAAW,uEAAsEzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAAC4B,MAAvB,CAA+B,EAAhH,CAAN;IACD;EACF,CA/IqC,CAgJtC;;;EACA,IAAG5B,OAAO,CAACsB,IAAR,KAAiBnB,SAAjB,IAA8BH,OAAO,CAACsB,IAAR,KAAiB,IAAlD,EAAuD;IACrDtB,OAAO,CAACsB,IAAR,GAAe,CAAf;EACD,CAFD,MAEK;IACH,IAAG,OAAOtB,OAAO,CAACsB,IAAf,KAAwB,QAAxB,IAAoC,MAAMQ,IAAN,CAAW9B,OAAO,CAACsB,IAAnB,CAAvC,EAAgE;MAC9DtB,OAAO,CAACsB,IAAR,GAAeS,QAAQ,CAAC/B,OAAO,CAACsB,IAAT,CAAvB;IACD;;IACD,IAAGU,MAAM,CAACC,SAAP,CAAiBjC,OAAO,CAACsB,IAAzB,CAAH,EAAkC;MAChC,IAAGtB,OAAO,CAACsB,IAAR,GAAe,CAAlB,EAAoB;QAClB,MAAM,IAAIO,KAAJ,CAAW,wDAAuDzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAACuB,IAApB,CAA0B,EAA5F,CAAN;MACD;IACF,CAJD,MAIK;MACH,MAAM,IAAIO,KAAJ,CAAW,gDAA+CzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACsB,IAAvB,CAA6B,EAAvF,CAAN;IACD;EACF,CA9JqC,CA+JtC;;;EACA,IAAGtB,OAAO,CAACkC,SAAR,KAAsB/B,SAAtB,IAAmCH,OAAO,CAACkC,SAAR,KAAsB,IAA5D,EAAiE;IAC/DlC,OAAO,CAACkC,SAAR,GAAoB,CAApB;EACD,CAFD,MAEK;IACH,IAAG,OAAOlC,OAAO,CAACkC,SAAf,KAA6B,QAA7B,IAAyC,MAAMJ,IAAN,CAAW9B,OAAO,CAACkC,SAAnB,CAA5C,EAA0E;MACxElC,OAAO,CAACkC,SAAR,GAAoBH,QAAQ,CAAC/B,OAAO,CAACkC,SAAT,CAA5B;IACD;;IACD,IAAGF,MAAM,CAACC,SAAP,CAAiBjC,OAAO,CAACkC,SAAzB,CAAH,EAAuC;MACrC,IAAGlC,OAAO,CAACkC,SAAR,IAAqB,CAAxB,EAA0B;QACxB,MAAM,IAAIL,KAAJ,CAAW,4EAA2EzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAACmC,SAApB,CAA+B,EAArH,CAAN;MACD;IACF,CAJD,MAIK;MACH,MAAM,IAAIL,KAAJ,CAAW,qDAAoDzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAACmC,SAApB,CAA+B,EAA9F,CAAN;IACD;EACF,CA7KqC,CA8KtC;;;EACA,IAAGlC,OAAO,CAACmC,sBAAR,KAAmChC,SAAnC,IAAgDH,OAAO,CAACmC,sBAAR,KAAmC,IAAtF,EAA2F;IACzFnC,OAAO,CAACmC,sBAAR,GAAiC,KAAjC;EACD,CAFD,MAEM,IAAG,OAAOnC,OAAO,CAACmC,sBAAf,KAA0C,QAA7C,EAAsD;IAC1DnC,OAAO,CAACmC,sBAAR,GAAiCC,IAAI,CAACC,KAAL,CAAWrC,OAAO,CAACmC,sBAAnB,CAAjC;;IACA,IAAGnC,OAAO,CAACmC,sBAAR,KAAmC,CAAtC,EAAwC;MACtCnC,OAAO,CAACmC,sBAAR,GAAiC,KAAjC;IACD;EACF,CALK,MAKA,IAAG,OAAOnC,OAAO,CAACmC,sBAAf,KAA0C,SAA7C,EAAuD;IAC3D,MAAM,IAAIvC,QAAJ,CAAa,2CAAb,EAA0D,CAC9D,0CAD8D,EAE9D,kDAF8D,EAG7D,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACmC,sBAAvB,CAA+C,EAHQ,CAA1D,EAIHnC,OAJG,CAAN;EAKD;;EACD,IAAGA,OAAO,CAACmC,sBAAR,KAAmC,IAAnC,IAA2CnC,OAAO,CAACgB,OAAR,KAAoB,KAAlE,EAAwE;IACtE,MAAM,IAAIpB,QAAJ,CAAa,6CAAb,EAA4D,CAChE,qCADgE,EAEhE,iDAFgE,CAA5D,EAGHI,OAHG,CAAN;EAID,CAlMqC,CAmMtC;;;EACA,IAAGA,OAAO,CAACsC,IAAR,KAAiBnC,SAAjB,IAA8BH,OAAO,CAACsC,IAAR,KAAiB,IAA/C,IAAuDtC,OAAO,CAACsC,IAAR,KAAiB,KAA3E,EAAiF;IAC/EtC,OAAO,CAACsC,IAAR,GAAe,KAAf;EACD,CAFD,MAEM,IAAGtC,OAAO,CAACsC,IAAR,KAAiB,IAApB,EAAyB;IAC7B,MAAM,IAAIT,KAAJ,CAAW,0CAAyCzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACsC,IAAvB,CAA6B,EAAjF,CAAN;EACD,CAxMqC,CAyMtC;;;EACA,IAAGtC,OAAO,CAACuC,eAAR,KAA4BpC,SAA5B,IAAyCH,OAAO,CAACuC,eAAR,KAA4B,IAArE,IAA6EvC,OAAO,CAACuC,eAAR,KAA4B,KAA5G,EAAkH;IAChHvC,OAAO,CAACuC,eAAR,GAA0B,CAA1B;EACD,CAFD,MAEM,IAAGP,MAAM,CAACC,SAAP,CAAiBjC,OAAO,CAACuC,eAAzB,KAA6CvC,OAAO,CAACuC,eAAR,IAA2B,CAA3E,EAA6E,CACjF;EACD,CAFK,MAEA,IAAG,OAAOvC,OAAO,CAACuC,eAAf,KAAmC,QAAnC,IAA+C,MAAMT,IAAN,CAAW9B,OAAO,CAACuC,eAAnB,CAAlD,EAAsF;IAC1FvC,OAAO,CAACuC,eAAR,GAA0BR,QAAQ,CAAC/B,OAAO,CAACuC,eAAT,CAAlC;EACD,CAFK,MAED;IACH,MAAM,IAAIV,KAAJ,CAAW,mEAAkEzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACuC,eAAvB,CAAwC,EAArH,CAAN;EACD,CAlNqC,CAmNtC;;;EACA,IAAGvC,OAAO,CAACwC,OAAR,KAAoBrC,SAApB,IAAiCH,OAAO,CAACwC,OAAR,KAAoB,IAArD,IAA6DxC,OAAO,CAACwC,OAAR,KAAoB,KAApF,EAA0F;IACxFxC,OAAO,CAACwC,OAAR,GAAkBrC,SAAlB;EACD,CAFD,MAEM,IAAGkB,MAAM,CAACE,QAAP,CAAgBvB,OAAO,CAACwC,OAAxB,CAAH,EAAoC;IACxC,IAAGxC,OAAO,CAACwC,OAAR,CAAgBd,MAAhB,KAA2B,CAA9B,EAAgC;MAC9B,MAAM,IAAIG,KAAJ,CAAW,oDAAX,CAAN;IACD;;IACD,IAAG7B,OAAO,CAACE,QAAR,KAAqB,IAAxB,EAA6B,CAC3B;IACD,CAFD,MAEK;MACHF,OAAO,CAACwC,OAAR,GAAkBxC,OAAO,CAACwC,OAAR,CAAgBC,QAAhB,CAAyBzC,OAAO,CAACE,QAAjC,CAAlB;IACD;EACF,CATK,MASA,IAAG,OAAOF,OAAO,CAACwC,OAAf,KAA2B,QAA9B,EAAuC;IAC3C,IAAGxC,OAAO,CAACwC,OAAR,CAAgBd,MAAhB,KAA2B,CAA9B,EAAgC;MAC9B,MAAM,IAAIG,KAAJ,CAAW,oDAAX,CAAN;IACD,CAH0C,CAI3C;;EACD,CALK,MAKA,IAAG,OAAO7B,OAAO,CAACwC,OAAf,KAA2B,QAA9B,EAAuC,CAC3C;IACA;IACA;IACA;EACD,CALK,MAKD;IACH,MAAM,IAAIX,KAAJ,CAAW,6DAA4D7B,OAAO,CAACwC,OAAQ,EAAvF,CAAN;EACD;;EACD,IAAGxC,OAAO,CAACwC,OAAR,KAAoBrC,SAAvB,EAAiC;IAC/B,IAAG,OAAOH,OAAO,CAACwC,OAAf,KAA2B,QAA9B,EAAuC;MACrC,IAAGxC,OAAO,CAACgB,OAAR,KAAoB,KAAvB,EAA6B;QAC3B,MAAMa,KAAK,CAAC,wFAAD,CAAX;MACD;IACF,CAJD,MAIK;MAAE;MACL,IAAG7B,OAAO,CAACgB,OAAR,KAAoB,KAAvB,EAA6B;QAC3B,MAAMa,KAAK,CAAC,uFAAD,CAAX;MACD;IACF;EACF,CAtPqC,CAuPtC;;;EACA,IAAG7B,OAAO,CAAC0C,SAAR,KAAsBvC,SAAtB,IAAmCH,OAAO,CAAC0C,SAAR,KAAsB,IAA5D,EAAiE;IAC/D1C,OAAO,CAAC0C,SAAR,GAAoBvC,SAApB;EACD,CAFD,MAEM,IAAG,OAAOH,OAAO,CAAC0C,SAAf,KAA6B,UAAhC,EAA2C;IAC/C,MAAM,IAAI9C,QAAJ,CAAa,8BAAb,EAA6C,CACjD,6BADiD,EAEjD,oBAFiD,EAGhD,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAAC0C,SAAvB,CAAkC,EAHQ,CAA7C,EAIH1C,OAJG,CAAN;EAKD,CAhQqC,CAiQtC;;;EACA,IAAGA,OAAO,CAAC2C,KAAR,KAAkB,IAAlB,IAA0B3C,OAAO,CAAC2C,KAAR,KAAkB,KAA5C,IAAqD3C,OAAO,CAAC2C,KAAR,KAAkB,EAA1E,EAA6E;IAC3E3C,OAAO,CAAC2C,KAAR,GAAgB,IAAhB;EACD,CAFD,MAEK;IACH,IAAG3C,OAAO,CAAC2C,KAAR,KAAkBxC,SAAlB,IAA+BH,OAAO,CAAC2C,KAAR,KAAkB,IAApD,EAAyD;MACvD3C,OAAO,CAAC2C,KAAR,GAAgBtB,MAAM,CAACC,IAAP,CAAY,GAAZ,EAAiBtB,OAAO,CAACE,QAAzB,CAAhB;IACD,CAFD,MAEM,IAAG,OAAOF,OAAO,CAAC2C,KAAf,KAAyB,QAA5B,EAAqC;MACzC3C,OAAO,CAAC2C,KAAR,GAAgBtB,MAAM,CAACC,IAAP,CAAYtB,OAAO,CAAC2C,KAApB,EAA2B3C,OAAO,CAACE,QAAnC,CAAhB;IACD;;IACD,IAAG,CAACmB,MAAM,CAACE,QAAP,CAAgBvB,OAAO,CAAC2C,KAAxB,CAAJ,EAAmC;MACjC,MAAM,IAAId,KAAJ,CAAW,2DAA0DzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAAC2C,KAAvB,CAA8B,EAAnG,CAAN;IACD;EACF,CA7QqC,CA8QtC;;;EACA,IAAG3C,OAAO,CAAC4C,GAAR,KAAgBzC,SAAhB,IAA6BH,OAAO,CAAC4C,GAAR,KAAgB,IAA7C,IAAqD5C,OAAO,CAAC4C,GAAR,KAAgB,KAAxE,EAA8E;IAC5E5C,OAAO,CAAC4C,GAAR,GAAc,KAAd;EACD,CAFD,MAEM,IAAG5C,OAAO,CAAC4C,GAAR,KAAgB,IAAnB,EAAwB;IAC5B,MAAM,IAAIf,KAAJ,CAAW,yCAAwCzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAAC4C,GAAvB,CAA4B,EAA/E,CAAN;EACD,CAnRqC,CAoRtC;;;EACA,IAAG5C,OAAO,CAAC6C,gBAAR,KAA6B1C,SAAhC,EAA0C;IACxCH,OAAO,CAAC6C,gBAAR,GAA2B,EAA3B;EACD,CAFD,MAEM,IAAG,OAAO7C,OAAO,CAAC6C,gBAAf,KAAoC,QAApC,IAAgDxB,MAAM,CAACE,QAAP,CAAgBvB,OAAO,CAAC6C,gBAAxB,CAAnD,EAA6F;IACjG,IAAG7C,OAAO,CAAC6C,gBAAR,CAAyBnB,MAAzB,KAAoC,CAAvC,EAAyC;MACvC,MAAM,IAAI9B,QAAJ,CAAa,qCAAb,EAAoD,CACxD,oCADwD,EAExD,6CAFwD,EAGvD,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAAC6C,gBAAvB,CAAyC,EAHQ,CAApD,EAIH7C,OAJG,CAAN;IAKD;;IACDA,OAAO,CAAC6C,gBAAR,GAA2B,CAAC7C,OAAO,CAAC6C,gBAAT,CAA3B;EACD,CATK,MASA,IAAG,CAAC5B,KAAK,CAACC,OAAN,CAAclB,OAAO,CAAC6C,gBAAtB,CAAJ,EAA4C;IAChD,MAAM,IAAIjD,QAAJ,CAAa,qCAAb,EAAoD,CACxD,oCADwD,EAExD,6DAFwD,EAGvD,OAAMQ,IAAI,CAACC,SAAL,CAAeL,OAAO,CAAC6C,gBAAvB,CAAyC,EAHQ,CAApD,EAIH7C,OAJG,CAAN;EAKD;;EACDA,OAAO,CAAC6C,gBAAR,GAA2B7C,OAAO,CAAC6C,gBAAR,CAAyBlB,GAAzB,CAA6B,UAASmB,EAAT,EAAaC,CAAb,EAAe;IACrE,IAAG,OAAOD,EAAP,KAAc,QAAd,IAA0B,CAAEzB,MAAM,CAACE,QAAP,CAAgBuB,EAAhB,CAA/B,EAAmD;MACjD,MAAM,IAAIlD,QAAJ,CAAa,qCAAb,EAAoD,CACxD,oCADwD,EAExD,4DAFwD,EAGvD,YAAWmD,CAAE,GAH0C,EAIvD,OAAM3C,IAAI,CAACC,SAAL,CAAeyC,EAAf,CAAmB,EAJ8B,CAApD,EAKH9C,OALG,CAAN;IAMD,CAPD,MAOM,IAAG8C,EAAE,CAACpB,MAAH,KAAc,CAAjB,EAAmB;MACvB,MAAM,IAAI9B,QAAJ,CAAa,qCAAb,EAAoD,CACxD,oCADwD,EAExD,4CAFwD,EAGvD,YAAWmD,CAAE,GAH0C,EAIvD,OAAM3C,IAAI,CAACC,SAAL,CAAeyC,EAAf,CAAmB,EAJ8B,CAApD,EAKH9C,OALG,CAAN;IAMD;;IACD,IAAG,OAAO8C,EAAP,KAAc,QAAjB,EAA0B;MACxBA,EAAE,GAAGzB,MAAM,CAACC,IAAP,CAAYwB,EAAZ,EAAgB9C,OAAO,CAACE,QAAxB,CAAL;IACD;;IACD,OAAO4C,EAAP;EACD,CApB0B,CAA3B,CAvSsC,CA4TtC;;EACA,IAAG,OAAO9C,OAAO,CAACgD,kBAAf,KAAsC,SAAzC,EAAmD,CACjD;EACD,CAFD,MAEM,IAAGhD,OAAO,CAACgD,kBAAR,KAA+B7C,SAA/B,IAA4CH,OAAO,CAACgD,kBAAR,KAA+B,IAA9E,EAAmF;IACvFhD,OAAO,CAACgD,kBAAR,GAA6B,KAA7B;EACD,CAFK,MAED;IACH,MAAM,IAAInB,KAAJ,CAAW,6DAA4DzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACgD,kBAAvB,CAA2C,EAAlH,CAAN;EACD;;EACD,IAAG,OAAOhD,OAAO,CAACiD,uBAAf,KAA2C,SAA9C,EAAwD,CACtD;EACD,CAFD,MAEM,IAAGjD,OAAO,CAACiD,uBAAR,KAAoC9C,SAApC,IAAiDH,OAAO,CAACiD,uBAAR,KAAoC,IAAxF,EAA6F;IACjGjD,OAAO,CAACiD,uBAAR,GAAkC,KAAlC;EACD,CAFK,MAED;IACH,MAAM,IAAIpB,KAAJ,CAAW,kEAAiEzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACiD,uBAAvB,CAAgD,EAA5H,CAAN;EACD;;EACD,IAAG,OAAOjD,OAAO,CAACkD,uBAAf,KAA2C,SAA9C,EAAwD,CACtD;EACD,CAFD,MAEM,IAAGlD,OAAO,CAACkD,uBAAR,KAAoC/C,SAApC,IAAiDH,OAAO,CAACkD,uBAAR,KAAoC,IAAxF,EAA6F;IACjGlD,OAAO,CAACkD,uBAAR,GAAkC,KAAlC;EACD,CAFK,MAED;IACH,MAAM,IAAIrB,KAAJ,CAAW,kEAAiEzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACkD,uBAAvB,CAAgD,EAA5H,CAAN;EACD,CAjVqC,CAkVtC;;;EACA,IAAG,OAAOlD,OAAO,CAACmD,YAAf,KAAgC,SAAnC,EAA6C,CAC3C;EACD,CAFD,MAEM,IAAGnD,OAAO,CAACmD,YAAR,KAAyBhD,SAAzB,IAAsCH,OAAO,CAACmD,YAAR,KAAyB,IAAlE,EAAuE;IAC3EnD,OAAO,CAACmD,YAAR,GAAuB,KAAvB;EACD,CAFK,MAED;IACH,MAAM,IAAItB,KAAJ,CAAW,uDAAsDzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACmD,YAAvB,CAAqC,EAAtG,CAAN;EACD,CAzVqC,CA0VtC;;;EACA,IAAG,OAAOnD,OAAO,CAACoD,gBAAf,KAAoC,SAAvC,EAAiD,CAC/C;EACD,CAFD,MAEM,IAAGpD,OAAO,CAACoD,gBAAR,KAA6BjD,SAA7B,IAA0CH,OAAO,CAACoD,gBAAR,KAA6B,IAA1E,EAA+E;IACnFpD,OAAO,CAACoD,gBAAR,GAA2B,KAA3B;EACD,CAFK,MAED;IACH,MAAM,IAAIvB,KAAJ,CAAW,2DAA0DzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACoD,gBAAvB,CAAyC,EAA9G,CAAN;EACD,CAjWqC,CAkWtC;;;EACA,IAAG,OAAOpD,OAAO,CAACqD,8BAAf,KAAkD,SAArD,EAA+D,CAC7D;EACD,CAFD,MAEM,IAAGrD,OAAO,CAACqD,8BAAR,KAA2ClD,SAA3C,IAAwDH,OAAO,CAACqD,8BAAR,KAA2C,IAAtG,EAA2G;IAC/GrD,OAAO,CAACqD,8BAAR,GAAyC,KAAzC;EACD,CAFK,MAED;IACH,MAAM,IAAIxB,KAAJ,CAAW,yEAAwEzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACqD,8BAAvB,CAAuD,EAA1I,CAAN;EACD,CAzWqC,CA0WtC;;;EACA,IAAG,OAAOrD,OAAO,CAACsD,uBAAf,KAA2C,SAA9C,EAAwD,CACtD;EACD,CAFD,MAEM,IAAGtD,OAAO,CAACsD,uBAAR,KAAoCnD,SAApC,IAAiDH,OAAO,CAACsD,uBAAR,KAAoC,IAAxF,EAA6F;IACjGtD,OAAO,CAACsD,uBAAR,GAAkC,KAAlC;EACD,CAFK,MAED;IACH,MAAM,IAAIzB,KAAJ,CAAW,kEAAiEzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACsD,uBAAvB,CAAgD,EAA5H,CAAN;EACD,CAjXqC,CAkXtC;;;EACA,IAAGtD,OAAO,CAACuD,KAAR,KAAkBpD,SAAlB,IAA+BH,OAAO,CAACuD,KAAR,KAAkB,IAAjD,IAAyDvD,OAAO,CAACuD,KAAR,KAAkB,KAA9E,EAAoF;IAClFvD,OAAO,CAACuD,KAAR,GAAgB,KAAhB;EACD,CAFD,MAEM,IAAGvD,OAAO,CAACuD,KAAR,KAAkB,IAArB,EAA0B;IAC9B,MAAM,IAAI1B,KAAJ,CAAW,gDAA+CzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACuD,KAAvB,CAA8B,EAAxF,CAAN;EACD,CAvXqC,CAwXtC;;;EACA,IAAGvD,OAAO,CAACwD,KAAR,KAAkBrD,SAAlB,IAA+BH,OAAO,CAACwD,KAAR,KAAkB,IAAjD,IAAyDxD,OAAO,CAACwD,KAAR,KAAkB,KAA9E,EAAoF;IAClFxD,OAAO,CAACwD,KAAR,GAAgB,KAAhB;EACD,CAFD,MAEM,IAAGxD,OAAO,CAACwD,KAAR,KAAkB,IAArB,EAA0B;IAC9B,MAAM,IAAI3B,KAAJ,CAAW,gDAA+CzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACwD,KAAvB,CAA8B,EAAxF,CAAN;EACD,CA7XqC,CA8XtC;;;EACA,IAAGxD,OAAO,CAACyD,IAAR,KAAiBtD,SAAjB,IAA8BH,OAAO,CAACyD,IAAR,KAAiB,IAA/C,IAAuDzD,OAAO,CAACyD,IAAR,KAAiB,KAA3E,EAAiF;IAC/EzD,OAAO,CAACyD,IAAR,GAAe,KAAf;EACD,CAFD,MAEM,IAAGzD,OAAO,CAACyD,IAAR,KAAiB,IAApB,EAAyB;IAC7B,MAAM,IAAI5B,KAAJ,CAAW,+CAA8CzB,IAAI,CAACC,SAAL,CAAeL,OAAO,CAACyD,IAAvB,CAA6B,EAAtF,CAAN;EACD,CAnYqC,CAoYtC;;;EACA,IAAGzD,OAAO,CAACyD,IAAR,KAAiB,IAAjB,IAAyB1D,IAAI,CAACyD,KAAL,KAAe,KAA3C,EAAiD;IAC/CxD,OAAO,CAACwD,KAAR,GAAgB,IAAhB;EACD,CAFD,MAEM,IAAGxD,OAAO,CAACwD,KAAR,KAAkB,IAArB,EAA0B;IAC9BxD,OAAO,CAACwD,KAAR,GAAgB,KAAhB;EACD;;EACD,IAAGxD,OAAO,CAACyD,IAAR,KAAiB,IAAjB,IAAyB1D,IAAI,CAACwD,KAAL,KAAe,KAA3C,EAAiD;IAC/CvD,OAAO,CAACuD,KAAR,GAAgB,IAAhB;EACD,CAFD,MAEM,IAAGvD,OAAO,CAACuD,KAAR,KAAkB,IAArB,EAA0B;IAC9BvD,OAAO,CAACuD,KAAR,GAAgB,KAAhB;EACD,CA9YqC,CA+YtC;;;EACA,IAAGvD,OAAO,CAAC0D,EAAR,KAAevD,SAAf,IAA4BH,OAAO,CAAC0D,EAAR,KAAe,IAA9C,EAAmD;IACjD1D,OAAO,CAAC0D,EAAR,GAAa,CAAC,CAAd;EACD,CAFD,MAEK;IACH,IAAG,OAAO1D,OAAO,CAAC0D,EAAf,KAAsB,QAAtB,IAAkC,MAAM5B,IAAN,CAAW9B,OAAO,CAAC0D,EAAnB,CAArC,EAA4D;MAC1D1D,OAAO,CAAC0D,EAAR,GAAa3B,QAAQ,CAAC/B,OAAO,CAAC0D,EAAT,CAArB;IACD;;IACD,IAAG1B,MAAM,CAACC,SAAP,CAAiBjC,OAAO,CAAC0D,EAAzB,CAAH,EAAgC;MAC9B,IAAG1D,OAAO,CAAC0D,EAAR,IAAc,CAAjB,EAAmB;QACjB,MAAM,IAAI7B,KAAJ,CAAW,qEAAoEzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAAC2D,EAApB,CAAwB,EAAvG,CAAN;MACD;IACF,CAJD,MAIK;MACH,MAAM,IAAI7B,KAAJ,CAAW,8CAA6CzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAAC2D,EAApB,CAAwB,EAAhF,CAAN;IACD;EACF,CA7ZqC,CA8ZtC;;;EACA,IAAG1D,OAAO,CAAC2D,OAAR,KAAoBxD,SAApB,IAAiCH,OAAO,CAAC2D,OAAR,KAAoB,IAAxD,EAA6D;IAC3D3D,OAAO,CAAC2D,OAAR,GAAkB,CAAC,CAAnB;EACD,CAFD,MAEK;IACH,IAAG,OAAO3D,OAAO,CAAC2D,OAAf,KAA2B,QAA3B,IAAuC,MAAM7B,IAAN,CAAW9B,OAAO,CAAC2D,OAAnB,CAA1C,EAAsE;MACpE3D,OAAO,CAAC2D,OAAR,GAAkB5B,QAAQ,CAAC/B,OAAO,CAAC2D,OAAT,CAA1B;IACD;;IACD,IAAG3B,MAAM,CAACC,SAAP,CAAiBjC,OAAO,CAAC2D,OAAzB,CAAH,EAAqC;MACnC,IAAG3D,OAAO,CAAC2D,OAAR,IAAmB,CAAtB,EAAwB;QACtB,MAAM,IAAI9B,KAAJ,CAAW,0EAAyEzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAAC4D,OAApB,CAA6B,EAAjH,CAAN;MACD;IACF,CAJD,MAIK;MACH,MAAM,IAAI9B,KAAJ,CAAW,mDAAkDzB,IAAI,CAACC,SAAL,CAAeN,IAAI,CAAC4D,OAApB,CAA6B,EAA1F,CAAN;IACD;EACF;;EACD,OAAO3D,OAAP;AACD,CA9aD;;AAgbA,SAAQF,iBAAR"},"metadata":{},"sourceType":"module"}