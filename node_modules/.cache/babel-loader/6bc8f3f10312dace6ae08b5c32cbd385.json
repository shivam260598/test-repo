{"ast":null,"code":"import { normalize_columns_array } from './normalize_columns_array.js';\nimport { init_state } from './init_state.js';\nimport { normalize_options } from './normalize_options.js';\nimport { CsvError } from './CsvError.js';\n\nconst isRecordEmpty = function (record) {\n  return record.every(field => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\n\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function () {\n  let original_options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function (i, bufLen, end) {\n      if (end) return false;\n      const {\n        encoding,\n        escape,\n        quote\n      } = this.options;\n      const {\n        quoting,\n        needMoreDataSize,\n        recordDelimiterMaxLength\n      } = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(needMoreDataSize, // Skip if the remaining buffer smaller than record delimiter\n      // If \"record_delimiter\" is yet to be discovered:\n      // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n      // 2. We set the length to windows line ending in the current encoding\n      // Note, that encoding is known from user or bom discovery at that point\n      // recordDelimiterMaxLength,\n      recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength, // Skip if remaining buffer can be an escaped quote\n      quoting ? (escape === null ? 0 : escape.length) + quote.length : 0, // Skip if remaining buffer can be record delimiter following the closing quote\n      quoting ? quote.length + recordDelimiterMaxLength : 0);\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function (nextBuf, end, push, close) {\n      const {\n        bom,\n        encoding,\n        from_line,\n        ltrim,\n        max_record_size,\n        raw,\n        relax_quotes,\n        rtrim,\n        skip_empty_lines,\n        to,\n        to_line\n      } = this.options;\n      let {\n        comment,\n        escape,\n        quote,\n        record_delimiter\n      } = this.options;\n      const {\n        bomSkipped,\n        previousBuf,\n        rawBuffer,\n        escapeIsQuote\n      } = this.state;\n      let buf;\n\n      if (previousBuf === undefined) {\n        if (nextBuf === undefined) {\n          // Handle empty string\n          close();\n          return;\n        } else {\n          buf = nextBuf;\n        }\n      } else if (previousBuf !== undefined && nextBuf === undefined) {\n        buf = previousBuf;\n      } else {\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      } // Handle UTF BOM\n\n\n      if (bomSkipped === false) {\n        if (bom === false) {\n          this.state.bomSkipped = true;\n        } else if (buf.length < 3) {\n          // No enough data\n          if (end === false) {\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        } else {\n          for (const encoding in boms) {\n            if (boms[encoding].compare(buf, 0, boms[encoding].length) === 0) {\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength); // Renormalize original options with the new encoding\n\n              this.options = normalize_options({ ...this.original_options,\n                encoding: encoding\n              }); // Options will re-evaluate the Buffer with the new encoding\n\n              ({\n                comment,\n                escape,\n                quote\n              } = this.options);\n              break;\n            }\n          }\n\n          this.state.bomSkipped = true;\n        }\n      }\n\n      const bufLen = buf.length;\n      let pos;\n\n      for (pos = 0; pos < bufLen; pos++) {\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if (this.__needMoreData(pos, bufLen, end)) {\n          break;\n        }\n\n        if (this.state.wasRowDelimiter === true) {\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n\n        if (to_line !== -1 && this.info.lines > to_line) {\n          this.state.stop = true;\n          close();\n          return;\n        } // Auto discovery of record_delimiter, unix, mac and windows supported\n\n\n        if (this.state.quoting === false && record_delimiter.length === 0) {\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n\n          if (record_delimiterCount) {\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n\n        const chr = buf[pos];\n\n        if (raw === true) {\n          rawBuffer.append(chr);\n        }\n\n        if ((chr === cr || chr === nl) && this.state.wasRowDelimiter === false) {\n          this.state.wasRowDelimiter = true;\n        } // Previous char was a valid escape char\n        // treat the current char as a regular char\n\n\n        if (this.state.escaping === true) {\n          this.state.escaping = false;\n        } else {\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if (escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen) {\n            if (escapeIsQuote) {\n              if (this.__isQuote(buf, pos + escape.length)) {\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            } else {\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          } // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n\n\n          if (this.state.commenting === false && this.__isQuote(buf, pos)) {\n            if (this.state.quoting === true) {\n              const nextChr = buf[pos + quote.length];\n\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos + quote.length);\n\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos + quote.length, nextChr);\n\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos + quote.length, nextChr);\n\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos + quote.length) : this.__isRecordDelimiter(nextChr, buf, pos + quote.length); // Escape a quote\n              // Treat next char as a regular character\n\n              if (escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)) {\n                pos += escape.length - 1;\n              } else if (!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable) {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              } else if (relax_quotes === false) {\n                const err = this.__error(new CsvError('CSV_INVALID_CLOSING_QUOTE', ['Invalid Closing Quote:', `got \"${String.fromCharCode(nextChr)}\"`, `at line ${this.info.lines}`, 'instead of delimiter, record delimiter, trimable character', '(if activated) or comment'], this.options, this.__infoField()));\n\n                if (err !== undefined) return err;\n              } else {\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            } else {\n              if (this.state.field.length !== 0) {\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if (relax_quotes === false) {\n                  const info = this.__infoField();\n\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n\n                  const err = this.__error(new CsvError('INVALID_OPENING_QUOTE', ['Invalid Opening Quote:', `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`, bom ? `(${bom} bom)` : undefined], this.options, info, {\n                    field: this.state.field\n                  }));\n\n                  if (err !== undefined) return err;\n                }\n              } else {\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n\n          if (this.state.quoting === false) {\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n\n            if (recordDelimiterLength !== 0) {\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0;\n\n              if (skipCommentLine) {\n                this.info.comment_lines++; // Skip full comment line\n              } else {\n                // Activate records emition if above from_line\n                if (this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1 : 0) >= from_line) {\n                  this.state.enabled = true;\n\n                  this.__resetField();\n\n                  this.__resetRecord();\n\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                } // Skip if line is empty and skip_empty_lines activated\n\n\n                if (skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0) {\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n\n                this.info.bytes = this.state.bufBytesStart + pos;\n\n                const errField = this.__onField();\n\n                if (errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n\n                const errRecord = this.__onRecord(push);\n\n                if (errRecord !== undefined) return errRecord;\n\n                if (to !== -1 && this.info.records >= to) {\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n\n            if (this.state.commenting) {\n              continue;\n            }\n\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n\n            if (commentCount !== 0) {\n              this.state.commenting = true;\n              continue;\n            }\n\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n\n            if (delimiterLength !== 0) {\n              this.info.bytes = this.state.bufBytesStart + pos;\n\n              const errField = this.__onField();\n\n              if (errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n\n        if (this.state.commenting === false) {\n          if (max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size) {\n            return this.__error(new CsvError('CSV_MAX_RECORD_SIZE', ['Max Record Size:', 'record exceed the maximum number of tolerated bytes', `of ${max_record_size}`, `at line ${this.info.lines}`], this.options, this.__infoField()));\n          }\n        }\n\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos); // rtrim in non quoting is handle in __onField\n\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n\n        if (lappend === true && rappend === true) {\n          this.state.field.append(chr);\n        } else if (rtrim === true && !this.__isCharTrimable(buf, pos)) {\n          return this.__error(new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', ['Invalid Closing Quote:', 'found non trimable byte after quote', `at line ${this.info.lines}`], this.options, this.__infoField()));\n        } else {\n          if (lappend === false) {\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n\n          continue;\n        }\n      }\n\n      if (end === true) {\n        // Ensure we are not ending in a quoting state\n        if (this.state.quoting === true) {\n          const err = this.__error(new CsvError('CSV_QUOTE_NOT_CLOSED', ['Quote Not Closed:', `the parsing is finished with an opening quote at line ${this.info.lines}`], this.options, this.__infoField()));\n\n          if (err !== undefined) return err;\n        } else {\n          // Skip last line if it has no characters\n          if (this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0) {\n            this.info.bytes = this.state.bufBytesStart + pos;\n\n            const errField = this.__onField();\n\n            if (errField !== undefined) return errField;\n\n            const errRecord = this.__onRecord(push);\n\n            if (errRecord !== undefined) return errRecord;\n          } else if (this.state.wasRowDelimiter === true) {\n            this.info.empty_lines++;\n          } else if (this.state.commenting === true) {\n            this.info.comment_lines++;\n          }\n        }\n      } else {\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n\n      if (this.state.wasRowDelimiter === true) {\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function (push) {\n      const {\n        columns,\n        group_columns_by_name,\n        encoding,\n        info,\n        from,\n        relax_column_count,\n        relax_column_count_less,\n        relax_column_count_more,\n        raw,\n        skip_records_with_empty_values\n      } = this.options;\n      const {\n        enabled,\n        record\n      } = this.state;\n\n      if (enabled === false) {\n        return this.__resetRecord();\n      } // Convert the first line into column names\n\n\n      const recordLength = record.length;\n\n      if (columns === true) {\n        if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n          this.__resetRecord();\n\n          return;\n        }\n\n        return this.__firstLineToColumns(record);\n      }\n\n      if (columns === false && this.info.records === 0) {\n        this.state.expectedRecordLength = recordLength;\n      }\n\n      if (recordLength !== this.state.expectedRecordLength) {\n        const err = columns === false ? new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', ['Invalid Record Length:', `expect ${this.state.expectedRecordLength},`, `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        }) : new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', ['Invalid Record Length:', `columns length is ${columns.length},`, // rename columns\n        `got ${recordLength} on line ${this.info.lines}`], this.options, this.__infoField(), {\n          record: record\n        });\n\n        if (relax_column_count === true || relax_column_count_less === true && recordLength < this.state.expectedRecordLength || relax_column_count_more === true && recordLength > this.state.expectedRecordLength) {\n          this.info.invalid_field_length++;\n          this.state.error = err; // Error is undefined with skip_records_with_error\n        } else {\n          const finalErr = this.__error(err);\n\n          if (finalErr) return finalErr;\n        }\n      }\n\n      if (skip_records_with_empty_values === true && isRecordEmpty(record)) {\n        this.__resetRecord();\n\n        return;\n      }\n\n      if (this.state.recordHasError === true) {\n        this.__resetRecord();\n\n        this.state.recordHasError = false;\n        return;\n      }\n\n      this.info.records++;\n\n      if (from === 1 || this.info.records >= from) {\n        const {\n          objname\n        } = this.options; // With columns, records are object\n\n        if (columns !== false) {\n          const obj = {}; // Transform record array to an object\n\n          for (let i = 0, l = record.length; i < l; i++) {\n            if (columns[i] === undefined || columns[i].disabled) continue; // Turn duplicate columns into an array\n\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          } // Without objname (default)\n\n\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: obj\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n\n            const err = this.__push(objname === undefined ? extRecord : [obj[objname], extRecord], push);\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? obj : [obj[objname], obj], push);\n\n            if (err) {\n              return err;\n            }\n          } // Without columns, records are array\n\n        } else {\n          if (raw === true || info === true) {\n            const extRecord = Object.assign({\n              record: record\n            }, raw === true ? {\n              raw: this.state.rawBuffer.toString(encoding)\n            } : {}, info === true ? {\n              info: this.__infoRecord()\n            } : {});\n\n            const err = this.__push(objname === undefined ? extRecord : [record[objname], extRecord], push);\n\n            if (err) {\n              return err;\n            }\n          } else {\n            const err = this.__push(objname === undefined ? record : [record[objname], record], push);\n\n            if (err) {\n              return err;\n            }\n          }\n        }\n      }\n\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function (record) {\n      const {\n        firstLineToHeaders\n      } = this.state;\n\n      try {\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n\n        if (!Array.isArray(headers)) {\n          return this.__error(new CsvError('CSV_INVALID_COLUMN_MAPPING', ['Invalid Column Mapping:', 'expect an array from column function,', `got ${JSON.stringify(headers)}`], this.options, this.__infoField(), {\n            headers: headers\n          }));\n        }\n\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n\n        this.__resetRecord();\n\n        return;\n      } catch (err) {\n        return err;\n      }\n    },\n    __resetRecord: function () {\n      if (this.options.raw === true) {\n        this.state.rawBuffer.reset();\n      }\n\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function () {\n      const {\n        cast,\n        encoding,\n        rtrim,\n        max_record_size\n      } = this.options;\n      const {\n        enabled,\n        wasQuoting\n      } = this.state; // Short circuit for the from_line options\n\n      if (enabled === false) {\n        return this.__resetField();\n      }\n\n      let field = this.state.field.toString(encoding);\n\n      if (rtrim === true && wasQuoting === false) {\n        field = field.trimRight();\n      }\n\n      if (cast === true) {\n        const [err, f] = this.__cast(field);\n\n        if (err !== undefined) return err;\n        field = f;\n      }\n\n      this.state.record.push(field); // Increment record length if record size must not exceed a limit\n\n      if (max_record_size !== 0 && typeof field === 'string') {\n        this.state.record_length += field.length;\n      }\n\n      this.__resetField();\n    },\n    __resetField: function () {\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function (record, push) {\n      const {\n        on_record\n      } = this.options;\n\n      if (on_record !== undefined) {\n        const info = this.__infoRecord();\n\n        try {\n          record = on_record.call(null, record, info);\n        } catch (err) {\n          return err;\n        }\n\n        if (record === undefined || record === null) {\n          return;\n        }\n      }\n\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function (field) {\n      const {\n        columns,\n        relax_column_count\n      } = this.options;\n      const isColumns = Array.isArray(columns); // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n\n      if (isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length) {\n        return [undefined, undefined];\n      }\n\n      if (this.state.castField !== null) {\n        try {\n          const info = this.__infoField();\n\n          return [undefined, this.state.castField.call(null, field, info)];\n        } catch (err) {\n          return [err];\n        }\n      }\n\n      if (this.__isFloat(field)) {\n        return [undefined, parseFloat(field)];\n      } else if (this.options.cast_date !== false) {\n        const info = this.__infoField();\n\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function (buf, pos) {\n      const isTrim = (buf, pos) => {\n        const {\n          timchars\n        } = this.state;\n\n        loop1: for (let i = 0; i < timchars.length; i++) {\n          const timchar = timchars[i];\n\n          for (let j = 0; j < timchar.length; j++) {\n            if (timchar[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return timchar.length;\n        }\n\n        return 0;\n      };\n\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function (value) {\n      return value - parseFloat(value) + 1 >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function (sourceBuf, targetBuf, targetPos, firstByte) {\n      if (sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n\n      for (let i = 1; i < sourceLength; i++) {\n        if (sourceBuf[i] !== targetBuf[targetPos + i]) return 0;\n      }\n\n      return sourceLength;\n    },\n    __isDelimiter: function (buf, pos, chr) {\n      const {\n        delimiter,\n        ignore_last_delimiters\n      } = this.options;\n\n      if (ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1) {\n        return 0;\n      } else if (ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1) {\n        return 0;\n      }\n\n      loop1: for (let i = 0; i < delimiter.length; i++) {\n        const del = delimiter[i];\n\n        if (del[0] === chr) {\n          for (let j = 1; j < del.length; j++) {\n            if (del[j] !== buf[pos + j]) continue loop1;\n          }\n\n          return del.length;\n        }\n      }\n\n      return 0;\n    },\n    __isRecordDelimiter: function (chr, buf, pos) {\n      const {\n        record_delimiter\n      } = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n\n      loop1: for (let i = 0; i < recordDelimiterLength; i++) {\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n\n        if (rd[0] !== chr) {\n          continue;\n        }\n\n        for (let j = 1; j < rdLength; j++) {\n          if (rd[j] !== buf[pos + j]) {\n            continue loop1;\n          }\n        }\n\n        return rd.length;\n      }\n\n      return 0;\n    },\n    __isEscape: function (buf, pos, chr) {\n      const {\n        escape\n      } = this.options;\n      if (escape === null) return false;\n      const l = escape.length;\n\n      if (escape[0] === chr) {\n        for (let i = 0; i < l; i++) {\n          if (escape[i] !== buf[pos + i]) {\n            return false;\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    },\n    __isQuote: function (buf, pos) {\n      const {\n        quote\n      } = this.options;\n      if (quote === null) return false;\n      const l = quote.length;\n\n      for (let i = 0; i < l; i++) {\n        if (quote[i] !== buf[pos + i]) {\n          return false;\n        }\n      }\n\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function (buf, pos) {\n      const {\n        encoding\n      } = this.options; // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n\n      const rds = [// Important, the windows line ending must be before mac os 9\n      Buffer.from('\\r\\n', encoding), Buffer.from('\\n', encoding), Buffer.from('\\r', encoding)];\n\n      loop: for (let i = 0; i < rds.length; i++) {\n        const l = rds[i].length;\n\n        for (let j = 0; j < l; j++) {\n          if (rds[i][j] !== buf[pos + j]) {\n            continue loop;\n          }\n        }\n\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n\n      return 0;\n    },\n    __error: function (msg) {\n      const {\n        encoding,\n        raw,\n        skip_records_with_error\n      } = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n\n      if (skip_records_with_error) {\n        this.state.recordHasError = true;\n\n        if (this.options.on_skip !== undefined) {\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        } // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n\n\n        return undefined;\n      } else {\n        return err;\n      }\n    },\n    __infoDataSet: function () {\n      return { ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function () {\n      const {\n        columns,\n        raw,\n        encoding\n      } = this.options;\n      return { ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function () {\n      const {\n        columns\n      } = this.options;\n      const isColumns = Array.isArray(columns);\n      return { ...this.__infoRecord(),\n        column: isColumns === true ? columns.length > this.state.record.length ? columns[this.state.record.length].name : null : this.state.record.length,\n        quoting: this.state.wasQuoting\n      };\n    }\n  };\n};\n\nexport { transform, CsvError };","map":{"version":3,"names":["normalize_columns_array","init_state","normalize_options","CsvError","isRecordEmpty","record","every","field","toString","trim","cr","nl","boms","Buffer","from","transform","original_options","info","bytes","comment_lines","empty_lines","invalid_field_length","lines","records","options","state","__needMoreData","i","bufLen","end","encoding","escape","quote","quoting","needMoreDataSize","recordDelimiterMaxLength","numOfCharLeft","requiredLength","Math","max","length","parse","nextBuf","push","close","bom","from_line","ltrim","max_record_size","raw","relax_quotes","rtrim","skip_empty_lines","to","to_line","comment","record_delimiter","bomSkipped","previousBuf","rawBuffer","escapeIsQuote","buf","undefined","concat","compare","bomLength","bufBytesStart","slice","pos","wasRowDelimiter","stop","record_delimiterCount","__autoDiscoverRecordDelimiter","chr","append","escaping","__isEscape","__isQuote","commenting","nextChr","isNextChrTrimable","__isCharTrimable","isNextChrComment","__compareBytes","isNextChrDelimiter","__isDelimiter","isNextChrRecordDelimiter","__isRecordDelimiter","wasQuoting","err","__error","String","fromCharCode","__infoField","prepend","Object","keys","map","b","equals","filter","Boolean","JSON","stringify","column","recordDelimiterLength","skipCommentLine","enabled","__resetField","__resetRecord","errField","__onField","errRecord","__onRecord","commentCount","delimiterLength","record_length","lappend","rappend","columns","group_columns_by_name","relax_column_count","relax_column_count_less","relax_column_count_more","skip_records_with_empty_values","recordLength","__firstLineToColumns","expectedRecordLength","error","finalErr","recordHasError","objname","obj","l","disabled","name","Array","isArray","extRecord","assign","__infoRecord","__push","firstLineToHeaders","headers","call","normalizedHeaders","reset","cast","trimRight","f","__cast","on_record","isColumns","castField","__isFloat","parseFloat","cast_date","isTrim","timchars","loop1","timchar","j","value","sourceBuf","targetBuf","targetPos","firstByte","sourceLength","delimiter","ignore_last_delimiters","del","rd","rdLength","rds","loop","msg","skip_records_with_error","Error","on_skip","__infoDataSet","header","index"],"sources":["/Users/shivamsingh/stocks-application/node_modules/csv-parse/lib/api/index.js"],"sourcesContent":["\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {init_state} from './init_state.js';\nimport {normalize_options} from './normalize_options.js';\nimport {CsvError} from './CsvError.js';\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {encoding, escape, quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else{\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else{\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else{\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else{\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else{\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else{\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else{\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                      bom ? `(${bom} bom)` : undefined\n                    ], this.options, info, {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else{\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else{\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else{\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else{\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else{\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else{\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else{\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from('\\r\\n', encoding),\n        Buffer.from('\\n', encoding),\n        Buffer.from('\\r', encoding),\n      ];\n      loop: for(let i = 0; i < rds.length; i++){\n        const l = rds[i].length;\n        for(let j = 0; j < l; j++){\n          if(rds[i][j] !== buf[pos + j]){\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else{\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\n\nexport {transform, CsvError};\n"],"mappings":"AACA,SAAQA,uBAAR,QAAsC,8BAAtC;AACA,SAAQC,UAAR,QAAyB,iBAAzB;AACA,SAAQC,iBAAR,QAAgC,wBAAhC;AACA,SAAQC,QAAR,QAAuB,eAAvB;;AAEA,MAAMC,aAAa,GAAG,UAASC,MAAT,EAAgB;EACpC,OAAOA,MAAM,CAACC,KAAP,CAAcC,KAAD,IAAWA,KAAK,IAAI,IAAT,IAAiBA,KAAK,CAACC,QAAN,IAAkBD,KAAK,CAACC,QAAN,GAAiBC,IAAjB,OAA4B,EAAvF,CAAP;AACD,CAFD;;AAIA,MAAMC,EAAE,GAAG,EAAX,C,CAAe;;AACf,MAAMC,EAAE,GAAG,EAAX,C,CAAe;;AAEf,MAAMC,IAAI,GAAG;EACX;EACA;EACA;EACA;EACA,QAAQC,MAAM,CAACC,IAAP,CAAY,CAAC,GAAD,EAAM,GAAN,EAAW,GAAX,CAAZ,CALG;EAMX;EACA;EACA;EACA,WAAWD,MAAM,CAACC,IAAP,CAAY,CAAC,GAAD,EAAM,GAAN,CAAZ;AATA,CAAb;;AAYA,MAAMC,SAAS,GAAG,YAAgC;EAAA,IAAvBC,gBAAuB,uEAAJ,EAAI;EAChD,MAAMC,IAAI,GAAG;IACXC,KAAK,EAAE,CADI;IAEXC,aAAa,EAAE,CAFJ;IAGXC,WAAW,EAAE,CAHF;IAIXC,oBAAoB,EAAE,CAJX;IAKXC,KAAK,EAAE,CALI;IAMXC,OAAO,EAAE;EANE,CAAb;EAQA,MAAMC,OAAO,GAAGtB,iBAAiB,CAACc,gBAAD,CAAjC;EACA,OAAO;IACLC,IAAI,EAAEA,IADD;IAELD,gBAAgB,EAAEA,gBAFb;IAGLQ,OAAO,EAAEA,OAHJ;IAILC,KAAK,EAAExB,UAAU,CAACuB,OAAD,CAJZ;IAKLE,cAAc,EAAE,UAASC,CAAT,EAAYC,MAAZ,EAAoBC,GAApB,EAAwB;MACtC,IAAGA,GAAH,EAAQ,OAAO,KAAP;MACR,MAAM;QAACC,QAAD;QAAWC,MAAX;QAAmBC;MAAnB,IAA4B,KAAKR,OAAvC;MACA,MAAM;QAACS,OAAD;QAAUC,gBAAV;QAA4BC;MAA5B,IAAwD,KAAKV,KAAnE;MACA,MAAMW,aAAa,GAAGR,MAAM,GAAGD,CAAT,GAAa,CAAnC;MACA,MAAMU,cAAc,GAAGC,IAAI,CAACC,GAAL,CACrBL,gBADqB,EAErB;MACA;MACA;MACA;MACA;MACA;MACAC,wBAAwB,KAAK,CAA7B,GAAiCtB,MAAM,CAACC,IAAP,CAAY,MAAZ,EAAoBgB,QAApB,EAA8BU,MAA/D,GAAwEL,wBARnD,EASrB;MACAF,OAAO,GAAI,CAACF,MAAM,KAAK,IAAX,GAAkB,CAAlB,GAAsBA,MAAM,CAACS,MAA9B,IAAwCR,KAAK,CAACQ,MAAlD,GAA4D,CAV9C,EAWrB;MACAP,OAAO,GAAID,KAAK,CAACQ,MAAN,GAAeL,wBAAnB,GAA+C,CAZjC,CAAvB;MAcA,OAAOC,aAAa,GAAGC,cAAvB;IACD,CAzBI;IA0BL;IACAI,KAAK,EAAE,UAASC,OAAT,EAAkBb,GAAlB,EAAuBc,IAAvB,EAA6BC,KAA7B,EAAmC;MACxC,MAAM;QAACC,GAAD;QAAMf,QAAN;QAAgBgB,SAAhB;QAA2BC,KAA3B;QAAkCC,eAAlC;QAAkDC,GAAlD;QAAuDC,YAAvD;QAAqEC,KAArE;QAA4EC,gBAA5E;QAA8FC,EAA9F;QAAkGC;MAAlG,IAA6G,KAAK9B,OAAxH;MACA,IAAI;QAAC+B,OAAD;QAAUxB,MAAV;QAAkBC,KAAlB;QAAyBwB;MAAzB,IAA6C,KAAKhC,OAAtD;MACA,MAAM;QAACiC,UAAD;QAAaC,WAAb;QAA0BC,SAA1B;QAAqCC;MAArC,IAAsD,KAAKnC,KAAjE;MACA,IAAIoC,GAAJ;;MACA,IAAGH,WAAW,KAAKI,SAAnB,EAA6B;QAC3B,IAAGpB,OAAO,KAAKoB,SAAf,EAAyB;UACvB;UACAlB,KAAK;UACL;QACD,CAJD,MAIK;UACHiB,GAAG,GAAGnB,OAAN;QACD;MACF,CARD,MAQM,IAAGgB,WAAW,KAAKI,SAAhB,IAA6BpB,OAAO,KAAKoB,SAA5C,EAAsD;QAC1DD,GAAG,GAAGH,WAAN;MACD,CAFK,MAED;QACHG,GAAG,GAAGhD,MAAM,CAACkD,MAAP,CAAc,CAACL,WAAD,EAAchB,OAAd,CAAd,CAAN;MACD,CAjBuC,CAkBxC;;;MACA,IAAGe,UAAU,KAAK,KAAlB,EAAwB;QACtB,IAAGZ,GAAG,KAAK,KAAX,EAAiB;UACf,KAAKpB,KAAL,CAAWgC,UAAX,GAAwB,IAAxB;QACD,CAFD,MAEM,IAAGI,GAAG,CAACrB,MAAJ,GAAa,CAAhB,EAAkB;UACtB;UACA,IAAGX,GAAG,KAAK,KAAX,EAAiB;YACf;YACA,KAAKJ,KAAL,CAAWiC,WAAX,GAAyBG,GAAzB;YACA;UACD;QACF,CAPK,MAOD;UACH,KAAI,MAAM/B,QAAV,IAAsBlB,IAAtB,EAA2B;YACzB,IAAGA,IAAI,CAACkB,QAAD,CAAJ,CAAekC,OAAf,CAAuBH,GAAvB,EAA4B,CAA5B,EAA+BjD,IAAI,CAACkB,QAAD,CAAJ,CAAeU,MAA9C,MAA0D,CAA7D,EAA+D;cAC7D;cACA,MAAMyB,SAAS,GAAGrD,IAAI,CAACkB,QAAD,CAAJ,CAAeU,MAAjC;cACA,KAAKf,KAAL,CAAWyC,aAAX,IAA4BD,SAA5B;cACAJ,GAAG,GAAGA,GAAG,CAACM,KAAJ,CAAUF,SAAV,CAAN,CAJ6D,CAK7D;;cACA,KAAKzC,OAAL,GAAetB,iBAAiB,CAAC,EAAC,GAAG,KAAKc,gBAAT;gBAA2Bc,QAAQ,EAAEA;cAArC,CAAD,CAAhC,CAN6D,CAO7D;;cACA,CAAC;gBAACyB,OAAD;gBAAUxB,MAAV;gBAAkBC;cAAlB,IAA4B,KAAKR,OAAlC;cACA;YACD;UACF;;UACD,KAAKC,KAAL,CAAWgC,UAAX,GAAwB,IAAxB;QACD;MACF;;MACD,MAAM7B,MAAM,GAAGiC,GAAG,CAACrB,MAAnB;MACA,IAAI4B,GAAJ;;MACA,KAAIA,GAAG,GAAG,CAAV,EAAaA,GAAG,GAAGxC,MAAnB,EAA2BwC,GAAG,EAA9B,EAAiC;QAC/B;QACA;QACA,IAAG,KAAK1C,cAAL,CAAoB0C,GAApB,EAAyBxC,MAAzB,EAAiCC,GAAjC,CAAH,EAAyC;UACvC;QACD;;QACD,IAAG,KAAKJ,KAAL,CAAW4C,eAAX,KAA+B,IAAlC,EAAuC;UACrC,KAAKpD,IAAL,CAAUK,KAAV;UACA,KAAKG,KAAL,CAAW4C,eAAX,GAA6B,KAA7B;QACD;;QACD,IAAGf,OAAO,KAAK,CAAC,CAAb,IAAkB,KAAKrC,IAAL,CAAUK,KAAV,GAAkBgC,OAAvC,EAA+C;UAC7C,KAAK7B,KAAL,CAAW6C,IAAX,GAAkB,IAAlB;UACA1B,KAAK;UACL;QACD,CAd8B,CAe/B;;;QACA,IAAG,KAAKnB,KAAL,CAAWQ,OAAX,KAAuB,KAAvB,IAAgCuB,gBAAgB,CAAChB,MAAjB,KAA4B,CAA/D,EAAiE;UAC/D,MAAM+B,qBAAqB,GAAG,KAAKC,6BAAL,CAAmCX,GAAnC,EAAwCO,GAAxC,CAA9B;;UACA,IAAGG,qBAAH,EAAyB;YACvBf,gBAAgB,GAAG,KAAKhC,OAAL,CAAagC,gBAAhC;UACD;QACF;;QACD,MAAMiB,GAAG,GAAGZ,GAAG,CAACO,GAAD,CAAf;;QACA,IAAGnB,GAAG,KAAK,IAAX,EAAgB;UACdU,SAAS,CAACe,MAAV,CAAiBD,GAAjB;QACD;;QACD,IAAG,CAACA,GAAG,KAAK/D,EAAR,IAAc+D,GAAG,KAAK9D,EAAvB,KAA8B,KAAKc,KAAL,CAAW4C,eAAX,KAA+B,KAAhE,EAAsE;UACpE,KAAK5C,KAAL,CAAW4C,eAAX,GAA6B,IAA7B;QACD,CA5B8B,CA6B/B;QACA;;;QACA,IAAG,KAAK5C,KAAL,CAAWkD,QAAX,KAAwB,IAA3B,EAAgC;UAC9B,KAAKlD,KAAL,CAAWkD,QAAX,GAAsB,KAAtB;QACD,CAFD,MAEK;UACH;UACA;UACA;UACA,IAAG5C,MAAM,KAAK,IAAX,IAAmB,KAAKN,KAAL,CAAWQ,OAAX,KAAuB,IAA1C,IAAkD,KAAK2C,UAAL,CAAgBf,GAAhB,EAAqBO,GAArB,EAA0BK,GAA1B,CAAlD,IAAoFL,GAAG,GAAGrC,MAAM,CAACS,MAAb,GAAsBZ,MAA7G,EAAoH;YAClH,IAAGgC,aAAH,EAAiB;cACf,IAAG,KAAKiB,SAAL,CAAehB,GAAf,EAAoBO,GAAG,GAACrC,MAAM,CAACS,MAA/B,CAAH,EAA0C;gBACxC,KAAKf,KAAL,CAAWkD,QAAX,GAAsB,IAAtB;gBACAP,GAAG,IAAIrC,MAAM,CAACS,MAAP,GAAgB,CAAvB;gBACA;cACD;YACF,CAND,MAMK;cACH,KAAKf,KAAL,CAAWkD,QAAX,GAAsB,IAAtB;cACAP,GAAG,IAAIrC,MAAM,CAACS,MAAP,GAAgB,CAAvB;cACA;YACD;UACF,CAhBE,CAiBH;UACA;;;UACA,IAAG,KAAKf,KAAL,CAAWqD,UAAX,KAA0B,KAA1B,IAAmC,KAAKD,SAAL,CAAehB,GAAf,EAAoBO,GAApB,CAAtC,EAA+D;YAC7D,IAAG,KAAK3C,KAAL,CAAWQ,OAAX,KAAuB,IAA1B,EAA+B;cAC7B,MAAM8C,OAAO,GAAGlB,GAAG,CAACO,GAAG,GAACpC,KAAK,CAACQ,MAAX,CAAnB;;cACA,MAAMwC,iBAAiB,GAAG7B,KAAK,IAAI,KAAK8B,gBAAL,CAAsBpB,GAAtB,EAA2BO,GAAG,GAACpC,KAAK,CAACQ,MAArC,CAAnC;;cACA,MAAM0C,gBAAgB,GAAG3B,OAAO,KAAK,IAAZ,IAAoB,KAAK4B,cAAL,CAAoB5B,OAApB,EAA6BM,GAA7B,EAAkCO,GAAG,GAACpC,KAAK,CAACQ,MAA5C,EAAoDuC,OAApD,CAA7C;;cACA,MAAMK,kBAAkB,GAAG,KAAKC,aAAL,CAAmBxB,GAAnB,EAAwBO,GAAG,GAACpC,KAAK,CAACQ,MAAlC,EAA0CuC,OAA1C,CAA3B;;cACA,MAAMO,wBAAwB,GAAG9B,gBAAgB,CAAChB,MAAjB,KAA4B,CAA5B,GAAgC,KAAKgC,6BAAL,CAAmCX,GAAnC,EAAwCO,GAAG,GAACpC,KAAK,CAACQ,MAAlD,CAAhC,GAA4F,KAAK+C,mBAAL,CAAyBR,OAAzB,EAAkClB,GAAlC,EAAuCO,GAAG,GAACpC,KAAK,CAACQ,MAAjD,CAA7H,CAL6B,CAM7B;cACA;;cACA,IAAGT,MAAM,KAAK,IAAX,IAAmB,KAAK6C,UAAL,CAAgBf,GAAhB,EAAqBO,GAArB,EAA0BK,GAA1B,CAAnB,IAAqD,KAAKI,SAAL,CAAehB,GAAf,EAAoBO,GAAG,GAAGrC,MAAM,CAACS,MAAjC,CAAxD,EAAiG;gBAC/F4B,GAAG,IAAIrC,MAAM,CAACS,MAAP,GAAgB,CAAvB;cACD,CAFD,MAEM,IAAG,CAACuC,OAAD,IAAYK,kBAAZ,IAAkCE,wBAAlC,IAA8DJ,gBAA9D,IAAkFF,iBAArF,EAAuG;gBAC3G,KAAKvD,KAAL,CAAWQ,OAAX,GAAqB,KAArB;gBACA,KAAKR,KAAL,CAAW+D,UAAX,GAAwB,IAAxB;gBACApB,GAAG,IAAIpC,KAAK,CAACQ,MAAN,GAAe,CAAtB;gBACA;cACD,CALK,MAKA,IAAGU,YAAY,KAAK,KAApB,EAA0B;gBAC9B,MAAMuC,GAAG,GAAG,KAAKC,OAAL,CACV,IAAIvF,QAAJ,CAAa,2BAAb,EAA0C,CACxC,wBADwC,EAEvC,QAAOwF,MAAM,CAACC,YAAP,CAAoBb,OAApB,CAA6B,GAFG,EAGvC,WAAU,KAAK9D,IAAL,CAAUK,KAAM,EAHa,EAIxC,4DAJwC,EAKxC,2BALwC,CAA1C,EAMG,KAAKE,OANR,EAMiB,KAAKqE,WAAL,EANjB,CADU,CAAZ;;gBASA,IAAGJ,GAAG,KAAK3B,SAAX,EAAsB,OAAO2B,GAAP;cACvB,CAXK,MAWD;gBACH,KAAKhE,KAAL,CAAWQ,OAAX,GAAqB,KAArB;gBACA,KAAKR,KAAL,CAAW+D,UAAX,GAAwB,IAAxB;gBACA,KAAK/D,KAAL,CAAWlB,KAAX,CAAiBuF,OAAjB,CAAyB9D,KAAzB;gBACAoC,GAAG,IAAIpC,KAAK,CAACQ,MAAN,GAAe,CAAtB;cACD;YACF,CAhCD,MAgCK;cACH,IAAG,KAAKf,KAAL,CAAWlB,KAAX,CAAiBiC,MAAjB,KAA4B,CAA/B,EAAiC;gBAC/B;gBACA,IAAGU,YAAY,KAAK,KAApB,EAA0B;kBACxB,MAAMjC,IAAI,GAAG,KAAK4E,WAAL,EAAb;;kBACA,MAAMhD,GAAG,GAAGkD,MAAM,CAACC,IAAP,CAAYpF,IAAZ,EAAkBqF,GAAlB,CAAsBC,CAAC,IAAItF,IAAI,CAACsF,CAAD,CAAJ,CAAQC,MAAR,CAAe,KAAK1E,KAAL,CAAWlB,KAAX,CAAiBC,QAAjB,EAAf,IAA8C0F,CAA9C,GAAkD,KAA7E,EAAoFE,MAApF,CAA2FC,OAA3F,EAAoG,CAApG,CAAZ;;kBACA,MAAMZ,GAAG,GAAG,KAAKC,OAAL,CACV,IAAIvF,QAAJ,CAAa,uBAAb,EAAsC,CACpC,wBADoC,EAEnC,6BAA4BmG,IAAI,CAACC,SAAL,CAAetF,IAAI,CAACuF,MAApB,CAA4B,YAAWvF,IAAI,CAACK,KAAM,cAAagF,IAAI,CAACC,SAAL,CAAe,KAAK9E,KAAL,CAAWlB,KAAX,CAAiBC,QAAjB,CAA0BsB,QAA1B,CAAf,CAAoD,EAF5G,EAGpCe,GAAG,GAAI,IAAGA,GAAI,OAAX,GAAoBiB,SAHa,CAAtC,EAIG,KAAKtC,OAJR,EAIiBP,IAJjB,EAIuB;oBACrBV,KAAK,EAAE,KAAKkB,KAAL,CAAWlB;kBADG,CAJvB,CADU,CAAZ;;kBASA,IAAGkF,GAAG,KAAK3B,SAAX,EAAsB,OAAO2B,GAAP;gBACvB;cACF,CAhBD,MAgBK;gBACH,KAAKhE,KAAL,CAAWQ,OAAX,GAAqB,IAArB;gBACAmC,GAAG,IAAIpC,KAAK,CAACQ,MAAN,GAAe,CAAtB;gBACA;cACD;YACF;UACF;;UACD,IAAG,KAAKf,KAAL,CAAWQ,OAAX,KAAuB,KAA1B,EAAgC;YAC9B,MAAMwE,qBAAqB,GAAG,KAAKlB,mBAAL,CAAyBd,GAAzB,EAA8BZ,GAA9B,EAAmCO,GAAnC,CAA9B;;YACA,IAAGqC,qBAAqB,KAAK,CAA7B,EAA+B;cAC7B;cACA,MAAMC,eAAe,GAAG,KAAKjF,KAAL,CAAWqD,UAAX,IAA0B,KAAKrD,KAAL,CAAW+D,UAAX,KAA0B,KAA1B,IAAmC,KAAK/D,KAAL,CAAWpB,MAAX,CAAkBmC,MAAlB,KAA6B,CAAhE,IAAqE,KAAKf,KAAL,CAAWlB,KAAX,CAAiBiC,MAAjB,KAA4B,CAAnJ;;cACA,IAAGkE,eAAH,EAAmB;gBACjB,KAAKzF,IAAL,CAAUE,aAAV,GADiB,CAEjB;cACD,CAHD,MAGK;gBACH;gBACA,IAAG,KAAKM,KAAL,CAAWkF,OAAX,KAAuB,KAAvB,IAAgC,KAAK1F,IAAL,CAAUK,KAAV,IAAmB,KAAKG,KAAL,CAAW4C,eAAX,KAA+B,IAA/B,GAAsC,CAAtC,GAAyC,CAA5D,KAAkEvB,SAArG,EAA+G;kBAC7G,KAAKrB,KAAL,CAAWkF,OAAX,GAAqB,IAArB;;kBACA,KAAKC,YAAL;;kBACA,KAAKC,aAAL;;kBACAzC,GAAG,IAAIqC,qBAAqB,GAAG,CAA/B;kBACA;gBACD,CARE,CASH;;;gBACA,IAAGrD,gBAAgB,KAAK,IAArB,IAA6B,KAAK3B,KAAL,CAAW+D,UAAX,KAA0B,KAAvD,IAAgE,KAAK/D,KAAL,CAAWpB,MAAX,CAAkBmC,MAAlB,KAA6B,CAA7F,IAAkG,KAAKf,KAAL,CAAWlB,KAAX,CAAiBiC,MAAjB,KAA4B,CAAjI,EAAmI;kBACjI,KAAKvB,IAAL,CAAUG,WAAV;kBACAgD,GAAG,IAAIqC,qBAAqB,GAAG,CAA/B;kBACA;gBACD;;gBACD,KAAKxF,IAAL,CAAUC,KAAV,GAAkB,KAAKO,KAAL,CAAWyC,aAAX,GAA2BE,GAA7C;;gBACA,MAAM0C,QAAQ,GAAG,KAAKC,SAAL,EAAjB;;gBACA,IAAGD,QAAQ,KAAKhD,SAAhB,EAA2B,OAAOgD,QAAP;gBAC3B,KAAK7F,IAAL,CAAUC,KAAV,GAAkB,KAAKO,KAAL,CAAWyC,aAAX,GAA2BE,GAA3B,GAAiCqC,qBAAnD;;gBACA,MAAMO,SAAS,GAAG,KAAKC,UAAL,CAAgBtE,IAAhB,CAAlB;;gBACA,IAAGqE,SAAS,KAAKlD,SAAjB,EAA4B,OAAOkD,SAAP;;gBAC5B,IAAG3D,EAAE,KAAK,CAAC,CAAR,IAAa,KAAKpC,IAAL,CAAUM,OAAV,IAAqB8B,EAArC,EAAwC;kBACtC,KAAK5B,KAAL,CAAW6C,IAAX,GAAkB,IAAlB;kBACA1B,KAAK;kBACL;gBACD;cACF;;cACD,KAAKnB,KAAL,CAAWqD,UAAX,GAAwB,KAAxB;cACAV,GAAG,IAAIqC,qBAAqB,GAAG,CAA/B;cACA;YACD;;YACD,IAAG,KAAKhF,KAAL,CAAWqD,UAAd,EAAyB;cACvB;YACD;;YACD,MAAMoC,YAAY,GAAG3D,OAAO,KAAK,IAAZ,GAAmB,CAAnB,GAAuB,KAAK4B,cAAL,CAAoB5B,OAApB,EAA6BM,GAA7B,EAAkCO,GAAlC,EAAuCK,GAAvC,CAA5C;;YACA,IAAGyC,YAAY,KAAK,CAApB,EAAsB;cACpB,KAAKzF,KAAL,CAAWqD,UAAX,GAAwB,IAAxB;cACA;YACD;;YACD,MAAMqC,eAAe,GAAG,KAAK9B,aAAL,CAAmBxB,GAAnB,EAAwBO,GAAxB,EAA6BK,GAA7B,CAAxB;;YACA,IAAG0C,eAAe,KAAK,CAAvB,EAAyB;cACvB,KAAKlG,IAAL,CAAUC,KAAV,GAAkB,KAAKO,KAAL,CAAWyC,aAAX,GAA2BE,GAA7C;;cACA,MAAM0C,QAAQ,GAAG,KAAKC,SAAL,EAAjB;;cACA,IAAGD,QAAQ,KAAKhD,SAAhB,EAA2B,OAAOgD,QAAP;cAC3B1C,GAAG,IAAI+C,eAAe,GAAG,CAAzB;cACA;YACD;UACF;QACF;;QACD,IAAG,KAAK1F,KAAL,CAAWqD,UAAX,KAA0B,KAA7B,EAAmC;UACjC,IAAG9B,eAAe,KAAK,CAApB,IAAyB,KAAKvB,KAAL,CAAW2F,aAAX,GAA2B,KAAK3F,KAAL,CAAWlB,KAAX,CAAiBiC,MAA5C,GAAqDQ,eAAjF,EAAiG;YAC/F,OAAO,KAAK0C,OAAL,CACL,IAAIvF,QAAJ,CAAa,qBAAb,EAAoC,CAClC,kBADkC,EAElC,qDAFkC,EAGjC,MAAK6C,eAAgB,EAHY,EAIjC,WAAU,KAAK/B,IAAL,CAAUK,KAAM,EAJO,CAApC,EAKG,KAAKE,OALR,EAKiB,KAAKqE,WAAL,EALjB,CADK,CAAP;UAQD;QACF;;QACD,MAAMwB,OAAO,GAAGtE,KAAK,KAAK,KAAV,IAAmB,KAAKtB,KAAL,CAAWQ,OAAX,KAAuB,IAA1C,IAAkD,KAAKR,KAAL,CAAWlB,KAAX,CAAiBiC,MAAjB,KAA4B,CAA9E,IAAmF,CAAC,KAAKyC,gBAAL,CAAsBpB,GAAtB,EAA2BO,GAA3B,CAApG,CAlL+B,CAmL/B;;QACA,MAAMkD,OAAO,GAAGnE,KAAK,KAAK,KAAV,IAAmB,KAAK1B,KAAL,CAAW+D,UAAX,KAA0B,KAA7D;;QACA,IAAG6B,OAAO,KAAK,IAAZ,IAAoBC,OAAO,KAAK,IAAnC,EAAwC;UACtC,KAAK7F,KAAL,CAAWlB,KAAX,CAAiBmE,MAAjB,CAAwBD,GAAxB;QACD,CAFD,MAEM,IAAGtB,KAAK,KAAK,IAAV,IAAkB,CAAC,KAAK8B,gBAAL,CAAsBpB,GAAtB,EAA2BO,GAA3B,CAAtB,EAAsD;UAC1D,OAAO,KAAKsB,OAAL,CACL,IAAIvF,QAAJ,CAAa,2CAAb,EAA0D,CACxD,wBADwD,EAExD,qCAFwD,EAGvD,WAAU,KAAKc,IAAL,CAAUK,KAAM,EAH6B,CAA1D,EAIG,KAAKE,OAJR,EAIiB,KAAKqE,WAAL,EAJjB,CADK,CAAP;QAOD,CARK,MAQD;UACH,IAAGwB,OAAO,KAAK,KAAf,EAAqB;YACnBjD,GAAG,IAAI,KAAKa,gBAAL,CAAsBpB,GAAtB,EAA2BO,GAA3B,IAAkC,CAAzC;UACD;;UACD;QACD;MACF;;MACD,IAAGvC,GAAG,KAAK,IAAX,EAAgB;QACd;QACA,IAAG,KAAKJ,KAAL,CAAWQ,OAAX,KAAuB,IAA1B,EAA+B;UAC7B,MAAMwD,GAAG,GAAG,KAAKC,OAAL,CACV,IAAIvF,QAAJ,CAAa,sBAAb,EAAqC,CACnC,mBADmC,EAElC,yDAAwD,KAAKc,IAAL,CAAUK,KAAM,EAFtC,CAArC,EAGG,KAAKE,OAHR,EAGiB,KAAKqE,WAAL,EAHjB,CADU,CAAZ;;UAMA,IAAGJ,GAAG,KAAK3B,SAAX,EAAsB,OAAO2B,GAAP;QACvB,CARD,MAQK;UACH;UACA,IAAG,KAAKhE,KAAL,CAAW+D,UAAX,KAA0B,IAA1B,IAAkC,KAAK/D,KAAL,CAAWpB,MAAX,CAAkBmC,MAAlB,KAA6B,CAA/D,IAAoE,KAAKf,KAAL,CAAWlB,KAAX,CAAiBiC,MAAjB,KAA4B,CAAnG,EAAqG;YACnG,KAAKvB,IAAL,CAAUC,KAAV,GAAkB,KAAKO,KAAL,CAAWyC,aAAX,GAA2BE,GAA7C;;YACA,MAAM0C,QAAQ,GAAG,KAAKC,SAAL,EAAjB;;YACA,IAAGD,QAAQ,KAAKhD,SAAhB,EAA2B,OAAOgD,QAAP;;YAC3B,MAAME,SAAS,GAAG,KAAKC,UAAL,CAAgBtE,IAAhB,CAAlB;;YACA,IAAGqE,SAAS,KAAKlD,SAAjB,EAA4B,OAAOkD,SAAP;UAC7B,CAND,MAMM,IAAG,KAAKvF,KAAL,CAAW4C,eAAX,KAA+B,IAAlC,EAAuC;YAC3C,KAAKpD,IAAL,CAAUG,WAAV;UACD,CAFK,MAEA,IAAG,KAAKK,KAAL,CAAWqD,UAAX,KAA0B,IAA7B,EAAkC;YACtC,KAAK7D,IAAL,CAAUE,aAAV;UACD;QACF;MACF,CAxBD,MAwBK;QACH,KAAKM,KAAL,CAAWyC,aAAX,IAA4BE,GAA5B;QACA,KAAK3C,KAAL,CAAWiC,WAAX,GAAyBG,GAAG,CAACM,KAAJ,CAAUC,GAAV,CAAzB;MACD;;MACD,IAAG,KAAK3C,KAAL,CAAW4C,eAAX,KAA+B,IAAlC,EAAuC;QACrC,KAAKpD,IAAL,CAAUK,KAAV;QACA,KAAKG,KAAL,CAAW4C,eAAX,GAA6B,KAA7B;MACD;IACF,CAjTI;IAkTL4C,UAAU,EAAE,UAAStE,IAAT,EAAc;MACxB,MAAM;QAAC4E,OAAD;QAAUC,qBAAV;QAAiC1F,QAAjC;QAA2Cb,IAA3C;QAAiDH,IAAjD;QAAuD2G,kBAAvD;QAA2EC,uBAA3E;QAAoGC,uBAApG;QAA6H1E,GAA7H;QAAkI2E;MAAlI,IAAoK,KAAKpG,OAA/K;MACA,MAAM;QAACmF,OAAD;QAAUtG;MAAV,IAAoB,KAAKoB,KAA/B;;MACA,IAAGkF,OAAO,KAAK,KAAf,EAAqB;QACnB,OAAO,KAAKE,aAAL,EAAP;MACD,CALuB,CAMxB;;;MACA,MAAMgB,YAAY,GAAGxH,MAAM,CAACmC,MAA5B;;MACA,IAAG+E,OAAO,KAAK,IAAf,EAAoB;QAClB,IAAGK,8BAA8B,KAAK,IAAnC,IAA2CxH,aAAa,CAACC,MAAD,CAA3D,EAAoE;UAClE,KAAKwG,aAAL;;UACA;QACD;;QACD,OAAO,KAAKiB,oBAAL,CAA0BzH,MAA1B,CAAP;MACD;;MACD,IAAGkH,OAAO,KAAK,KAAZ,IAAqB,KAAKtG,IAAL,CAAUM,OAAV,KAAsB,CAA9C,EAAgD;QAC9C,KAAKE,KAAL,CAAWsG,oBAAX,GAAkCF,YAAlC;MACD;;MACD,IAAGA,YAAY,KAAK,KAAKpG,KAAL,CAAWsG,oBAA/B,EAAoD;QAClD,MAAMtC,GAAG,GAAG8B,OAAO,KAAK,KAAZ,GACV,IAAIpH,QAAJ,CAAa,uCAAb,EAAsD,CACpD,wBADoD,EAEnD,UAAS,KAAKsB,KAAL,CAAWsG,oBAAqB,GAFU,EAGnD,OAAMF,YAAa,YAAW,KAAK5G,IAAL,CAAUK,KAAM,EAHK,CAAtD,EAIG,KAAKE,OAJR,EAIiB,KAAKqE,WAAL,EAJjB,EAIqC;UACnCxF,MAAM,EAAEA;QAD2B,CAJrC,CADU,GASV,IAAIF,QAAJ,CAAa,iCAAb,EAAgD,CAC9C,wBAD8C,EAE7C,qBAAoBoH,OAAO,CAAC/E,MAAO,GAFU,EAEN;QACvC,OAAMqF,YAAa,YAAW,KAAK5G,IAAL,CAAUK,KAAM,EAHD,CAAhD,EAIG,KAAKE,OAJR,EAIiB,KAAKqE,WAAL,EAJjB,EAIqC;UACnCxF,MAAM,EAAEA;QAD2B,CAJrC,CATF;;QAgBA,IAAGoH,kBAAkB,KAAK,IAAvB,IACAC,uBAAuB,KAAK,IAA5B,IAAoCG,YAAY,GAAG,KAAKpG,KAAL,CAAWsG,oBAD9D,IAEAJ,uBAAuB,KAAK,IAA5B,IAAoCE,YAAY,GAAG,KAAKpG,KAAL,CAAWsG,oBAFjE,EAEuF;UACrF,KAAK9G,IAAL,CAAUI,oBAAV;UACA,KAAKI,KAAL,CAAWuG,KAAX,GAAmBvC,GAAnB,CAFqF,CAGvF;QACC,CAND,MAMK;UACH,MAAMwC,QAAQ,GAAG,KAAKvC,OAAL,CAAaD,GAAb,CAAjB;;UACA,IAAGwC,QAAH,EAAa,OAAOA,QAAP;QACd;MACF;;MACD,IAAGL,8BAA8B,KAAK,IAAnC,IAA2CxH,aAAa,CAACC,MAAD,CAA3D,EAAoE;QAClE,KAAKwG,aAAL;;QACA;MACD;;MACD,IAAG,KAAKpF,KAAL,CAAWyG,cAAX,KAA8B,IAAjC,EAAsC;QACpC,KAAKrB,aAAL;;QACA,KAAKpF,KAAL,CAAWyG,cAAX,GAA4B,KAA5B;QACA;MACD;;MACD,KAAKjH,IAAL,CAAUM,OAAV;;MACA,IAAGT,IAAI,KAAK,CAAT,IAAc,KAAKG,IAAL,CAAUM,OAAV,IAAqBT,IAAtC,EAA2C;QACzC,MAAM;UAACqH;QAAD,IAAY,KAAK3G,OAAvB,CADyC,CAEzC;;QACA,IAAG+F,OAAO,KAAK,KAAf,EAAqB;UACnB,MAAMa,GAAG,GAAG,EAAZ,CADmB,CAEnB;;UACA,KAAI,IAAIzG,CAAC,GAAG,CAAR,EAAW0G,CAAC,GAAGhI,MAAM,CAACmC,MAA1B,EAAkCb,CAAC,GAAG0G,CAAtC,EAAyC1G,CAAC,EAA1C,EAA6C;YAC3C,IAAG4F,OAAO,CAAC5F,CAAD,CAAP,KAAemC,SAAf,IAA4ByD,OAAO,CAAC5F,CAAD,CAAP,CAAW2G,QAA1C,EAAoD,SADT,CAE3C;;YACA,IAAId,qBAAqB,KAAK,IAA1B,IAAkCY,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAH,KAAyBzE,SAA/D,EAA0E;cACxE,IAAI0E,KAAK,CAACC,OAAN,CAAcL,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAjB,CAAJ,EAAyC;gBACvCH,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAH,GAAuBH,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAH,CAAqBxE,MAArB,CAA4B1D,MAAM,CAACsB,CAAD,CAAlC,CAAvB;cACD,CAFD,MAEO;gBACLyG,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAH,GAAuB,CAACH,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAJ,EAAuBlI,MAAM,CAACsB,CAAD,CAA7B,CAAvB;cACD;YACF,CAND,MAMO;cACLyG,GAAG,CAACb,OAAO,CAAC5F,CAAD,CAAP,CAAW4G,IAAZ,CAAH,GAAuBlI,MAAM,CAACsB,CAAD,CAA7B;YACD;UACF,CAfkB,CAgBnB;;;UACA,IAAGsB,GAAG,KAAK,IAAR,IAAgBhC,IAAI,KAAK,IAA5B,EAAiC;YAC/B,MAAMyH,SAAS,GAAG3C,MAAM,CAAC4C,MAAP,CAChB;cAACtI,MAAM,EAAE+H;YAAT,CADgB,EAEfnF,GAAG,KAAK,IAAR,GAAe;cAACA,GAAG,EAAE,KAAKxB,KAAL,CAAWkC,SAAX,CAAqBnD,QAArB,CAA8BsB,QAA9B;YAAN,CAAf,GAA+D,EAFhD,EAGfb,IAAI,KAAK,IAAT,GAAgB;cAACA,IAAI,EAAE,KAAK2H,YAAL;YAAP,CAAhB,GAA6C,EAH9B,CAAlB;;YAKA,MAAMnD,GAAG,GAAG,KAAKoD,MAAL,CACVV,OAAO,KAAKrE,SAAZ,GAAwB4E,SAAxB,GAAoC,CAACN,GAAG,CAACD,OAAD,CAAJ,EAAeO,SAAf,CAD1B,EAER/F,IAFQ,CAAZ;;YAGA,IAAG8C,GAAH,EAAO;cACL,OAAOA,GAAP;YACD;UACF,CAZD,MAYK;YACH,MAAMA,GAAG,GAAG,KAAKoD,MAAL,CACVV,OAAO,KAAKrE,SAAZ,GAAwBsE,GAAxB,GAA8B,CAACA,GAAG,CAACD,OAAD,CAAJ,EAAeC,GAAf,CADpB,EAERzF,IAFQ,CAAZ;;YAGA,IAAG8C,GAAH,EAAO;cACL,OAAOA,GAAP;YACD;UACF,CApCkB,CAqCrB;;QACC,CAtCD,MAsCK;UACH,IAAGxC,GAAG,KAAK,IAAR,IAAgBhC,IAAI,KAAK,IAA5B,EAAiC;YAC/B,MAAMyH,SAAS,GAAG3C,MAAM,CAAC4C,MAAP,CAChB;cAACtI,MAAM,EAAEA;YAAT,CADgB,EAEhB4C,GAAG,KAAK,IAAR,GAAe;cAACA,GAAG,EAAE,KAAKxB,KAAL,CAAWkC,SAAX,CAAqBnD,QAArB,CAA8BsB,QAA9B;YAAN,CAAf,GAA+D,EAF/C,EAGhBb,IAAI,KAAK,IAAT,GAAgB;cAACA,IAAI,EAAE,KAAK2H,YAAL;YAAP,CAAhB,GAA6C,EAH7B,CAAlB;;YAKA,MAAMnD,GAAG,GAAG,KAAKoD,MAAL,CACVV,OAAO,KAAKrE,SAAZ,GAAwB4E,SAAxB,GAAoC,CAACrI,MAAM,CAAC8H,OAAD,CAAP,EAAkBO,SAAlB,CAD1B,EAER/F,IAFQ,CAAZ;;YAGA,IAAG8C,GAAH,EAAO;cACL,OAAOA,GAAP;YACD;UACF,CAZD,MAYK;YACH,MAAMA,GAAG,GAAG,KAAKoD,MAAL,CACVV,OAAO,KAAKrE,SAAZ,GAAwBzD,MAAxB,GAAiC,CAACA,MAAM,CAAC8H,OAAD,CAAP,EAAkB9H,MAAlB,CADvB,EAERsC,IAFQ,CAAZ;;YAGA,IAAG8C,GAAH,EAAO;cACL,OAAOA,GAAP;YACD;UACF;QACF;MACF;;MACD,KAAKoB,aAAL;IACD,CA3aI;IA4aLiB,oBAAoB,EAAE,UAASzH,MAAT,EAAgB;MACpC,MAAM;QAACyI;MAAD,IAAuB,KAAKrH,KAAlC;;MACA,IAAG;QACD,MAAMsH,OAAO,GAAGD,kBAAkB,KAAKhF,SAAvB,GAAmCzD,MAAnC,GAA4CyI,kBAAkB,CAACE,IAAnB,CAAwB,IAAxB,EAA8B3I,MAA9B,CAA5D;;QACA,IAAG,CAACmI,KAAK,CAACC,OAAN,CAAcM,OAAd,CAAJ,EAA2B;UACzB,OAAO,KAAKrD,OAAL,CACL,IAAIvF,QAAJ,CAAa,4BAAb,EAA2C,CACzC,yBADyC,EAEzC,uCAFyC,EAGxC,OAAMmG,IAAI,CAACC,SAAL,CAAewC,OAAf,CAAwB,EAHU,CAA3C,EAIG,KAAKvH,OAJR,EAIiB,KAAKqE,WAAL,EAJjB,EAIqC;YACnCkD,OAAO,EAAEA;UAD0B,CAJrC,CADK,CAAP;QASD;;QACD,MAAME,iBAAiB,GAAGjJ,uBAAuB,CAAC+I,OAAD,CAAjD;QACA,KAAKtH,KAAL,CAAWsG,oBAAX,GAAkCkB,iBAAiB,CAACzG,MAApD;QACA,KAAKhB,OAAL,CAAa+F,OAAb,GAAuB0B,iBAAvB;;QACA,KAAKpC,aAAL;;QACA;MACD,CAlBD,CAkBC,OAAMpB,GAAN,EAAU;QACT,OAAOA,GAAP;MACD;IACF,CAncI;IAocLoB,aAAa,EAAE,YAAU;MACvB,IAAG,KAAKrF,OAAL,CAAayB,GAAb,KAAqB,IAAxB,EAA6B;QAC3B,KAAKxB,KAAL,CAAWkC,SAAX,CAAqBuF,KAArB;MACD;;MACD,KAAKzH,KAAL,CAAWuG,KAAX,GAAmBlE,SAAnB;MACA,KAAKrC,KAAL,CAAWpB,MAAX,GAAoB,EAApB;MACA,KAAKoB,KAAL,CAAW2F,aAAX,GAA2B,CAA3B;IACD,CA3cI;IA4cLL,SAAS,EAAE,YAAU;MACnB,MAAM;QAACoC,IAAD;QAAOrH,QAAP;QAAiBqB,KAAjB;QAAwBH;MAAxB,IAA2C,KAAKxB,OAAtD;MACA,MAAM;QAACmF,OAAD;QAAUnB;MAAV,IAAwB,KAAK/D,KAAnC,CAFmB,CAGnB;;MACA,IAAGkF,OAAO,KAAK,KAAf,EAAqB;QACnB,OAAO,KAAKC,YAAL,EAAP;MACD;;MACD,IAAIrG,KAAK,GAAG,KAAKkB,KAAL,CAAWlB,KAAX,CAAiBC,QAAjB,CAA0BsB,QAA1B,CAAZ;;MACA,IAAGqB,KAAK,KAAK,IAAV,IAAkBqC,UAAU,KAAK,KAApC,EAA0C;QACxCjF,KAAK,GAAGA,KAAK,CAAC6I,SAAN,EAAR;MACD;;MACD,IAAGD,IAAI,KAAK,IAAZ,EAAiB;QACf,MAAM,CAAC1D,GAAD,EAAM4D,CAAN,IAAW,KAAKC,MAAL,CAAY/I,KAAZ,CAAjB;;QACA,IAAGkF,GAAG,KAAK3B,SAAX,EAAsB,OAAO2B,GAAP;QACtBlF,KAAK,GAAG8I,CAAR;MACD;;MACD,KAAK5H,KAAL,CAAWpB,MAAX,CAAkBsC,IAAlB,CAAuBpC,KAAvB,EAhBmB,CAiBnB;;MACA,IAAGyC,eAAe,KAAK,CAApB,IAAyB,OAAOzC,KAAP,KAAiB,QAA7C,EAAsD;QACpD,KAAKkB,KAAL,CAAW2F,aAAX,IAA4B7G,KAAK,CAACiC,MAAlC;MACD;;MACD,KAAKoE,YAAL;IACD,CAleI;IAmeLA,YAAY,EAAE,YAAU;MACtB,KAAKnF,KAAL,CAAWlB,KAAX,CAAiB2I,KAAjB;MACA,KAAKzH,KAAL,CAAW+D,UAAX,GAAwB,KAAxB;IACD,CAteI;IAueLqD,MAAM,EAAE,UAASxI,MAAT,EAAiBsC,IAAjB,EAAsB;MAC5B,MAAM;QAAC4G;MAAD,IAAc,KAAK/H,OAAzB;;MACA,IAAG+H,SAAS,KAAKzF,SAAjB,EAA2B;QACzB,MAAM7C,IAAI,GAAG,KAAK2H,YAAL,EAAb;;QACA,IAAG;UACDvI,MAAM,GAAGkJ,SAAS,CAACP,IAAV,CAAe,IAAf,EAAqB3I,MAArB,EAA6BY,IAA7B,CAAT;QACD,CAFD,CAEC,OAAMwE,GAAN,EAAU;UACT,OAAOA,GAAP;QACD;;QACD,IAAGpF,MAAM,KAAKyD,SAAX,IAAwBzD,MAAM,KAAK,IAAtC,EAA2C;UAAE;QAAS;MACvD;;MACDsC,IAAI,CAACtC,MAAD,CAAJ;IACD,CAnfI;IAofL;IACAiJ,MAAM,EAAE,UAAS/I,KAAT,EAAe;MACrB,MAAM;QAACgH,OAAD;QAAUE;MAAV,IAAgC,KAAKjG,OAA3C;MACA,MAAMgI,SAAS,GAAGhB,KAAK,CAACC,OAAN,CAAclB,OAAd,CAAlB,CAFqB,CAGrB;MACA;MACA;;MACA,IAAGiC,SAAS,KAAK,IAAd,IAAsB/B,kBAAtB,IAA4C,KAAKjG,OAAL,CAAa+F,OAAb,CAAqB/E,MAArB,IAA+B,KAAKf,KAAL,CAAWpB,MAAX,CAAkBmC,MAAhG,EAAuG;QACrG,OAAO,CAACsB,SAAD,EAAYA,SAAZ,CAAP;MACD;;MACD,IAAG,KAAKrC,KAAL,CAAWgI,SAAX,KAAyB,IAA5B,EAAiC;QAC/B,IAAG;UACD,MAAMxI,IAAI,GAAG,KAAK4E,WAAL,EAAb;;UACA,OAAO,CAAC/B,SAAD,EAAY,KAAKrC,KAAL,CAAWgI,SAAX,CAAqBT,IAArB,CAA0B,IAA1B,EAAgCzI,KAAhC,EAAuCU,IAAvC,CAAZ,CAAP;QACD,CAHD,CAGC,OAAMwE,GAAN,EAAU;UACT,OAAO,CAACA,GAAD,CAAP;QACD;MACF;;MACD,IAAG,KAAKiE,SAAL,CAAenJ,KAAf,CAAH,EAAyB;QACvB,OAAO,CAACuD,SAAD,EAAY6F,UAAU,CAACpJ,KAAD,CAAtB,CAAP;MACD,CAFD,MAEM,IAAG,KAAKiB,OAAL,CAAaoI,SAAb,KAA2B,KAA9B,EAAoC;QACxC,MAAM3I,IAAI,GAAG,KAAK4E,WAAL,EAAb;;QACA,OAAO,CAAC/B,SAAD,EAAY,KAAKtC,OAAL,CAAaoI,SAAb,CAAuBZ,IAAvB,CAA4B,IAA5B,EAAkCzI,KAAlC,EAAyCU,IAAzC,CAAZ,CAAP;MACD;;MACD,OAAO,CAAC6C,SAAD,EAAYvD,KAAZ,CAAP;IACD,CA7gBI;IA8gBL;IACA0E,gBAAgB,EAAE,UAASpB,GAAT,EAAcO,GAAd,EAAkB;MAClC,MAAMyF,MAAM,GAAG,CAAChG,GAAD,EAAMO,GAAN,KAAc;QAC3B,MAAM;UAAC0F;QAAD,IAAa,KAAKrI,KAAxB;;QACAsI,KAAK,EAAE,KAAI,IAAIpI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGmI,QAAQ,CAACtH,MAA5B,EAAoCb,CAAC,EAArC,EAAwC;UAC7C,MAAMqI,OAAO,GAAGF,QAAQ,CAACnI,CAAD,CAAxB;;UACA,KAAI,IAAIsI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGD,OAAO,CAACxH,MAA3B,EAAmCyH,CAAC,EAApC,EAAuC;YACrC,IAAGD,OAAO,CAACC,CAAD,CAAP,KAAepG,GAAG,CAACO,GAAG,GAAC6F,CAAL,CAArB,EAA8B,SAASF,KAAT;UAC/B;;UACD,OAAOC,OAAO,CAACxH,MAAf;QACD;;QACD,OAAO,CAAP;MACD,CAVD;;MAWA,OAAOqH,MAAM,CAAChG,GAAD,EAAMO,GAAN,CAAb;IACD,CA5hBI;IA6hBL;IACA;IACA;IACA;IACA;IACA;IACAsF,SAAS,EAAE,UAASQ,KAAT,EAAe;MACxB,OAAQA,KAAK,GAAGP,UAAU,CAACO,KAAD,CAAlB,GAA4B,CAA7B,IAAmC,CAA1C,CADwB,CACqB;IAC9C,CAriBI;IAsiBL/E,cAAc,EAAE,UAASgF,SAAT,EAAoBC,SAApB,EAA+BC,SAA/B,EAA0CC,SAA1C,EAAoD;MAClE,IAAGH,SAAS,CAAC,CAAD,CAAT,KAAiBG,SAApB,EAA+B,OAAO,CAAP;MAC/B,MAAMC,YAAY,GAAGJ,SAAS,CAAC3H,MAA/B;;MACA,KAAI,IAAIb,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG4I,YAAnB,EAAiC5I,CAAC,EAAlC,EAAqC;QACnC,IAAGwI,SAAS,CAACxI,CAAD,CAAT,KAAiByI,SAAS,CAACC,SAAS,GAAC1I,CAAX,CAA7B,EAA4C,OAAO,CAAP;MAC7C;;MACD,OAAO4I,YAAP;IACD,CA7iBI;IA8iBLlF,aAAa,EAAE,UAASxB,GAAT,EAAcO,GAAd,EAAmBK,GAAnB,EAAuB;MACpC,MAAM;QAAC+F,SAAD;QAAYC;MAAZ,IAAsC,KAAKjJ,OAAjD;;MACA,IAAGiJ,sBAAsB,KAAK,IAA3B,IAAmC,KAAKhJ,KAAL,CAAWpB,MAAX,CAAkBmC,MAAlB,KAA6B,KAAKhB,OAAL,CAAa+F,OAAb,CAAqB/E,MAArB,GAA8B,CAAjG,EAAmG;QACjG,OAAO,CAAP;MACD,CAFD,MAEM,IAAGiI,sBAAsB,KAAK,KAA3B,IAAoC,OAAOA,sBAAP,KAAkC,QAAtE,IAAkF,KAAKhJ,KAAL,CAAWpB,MAAX,CAAkBmC,MAAlB,KAA6BiI,sBAAsB,GAAG,CAA3I,EAA6I;QACjJ,OAAO,CAAP;MACD;;MACDV,KAAK,EAAE,KAAI,IAAIpI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG6I,SAAS,CAAChI,MAA7B,EAAqCb,CAAC,EAAtC,EAAyC;QAC9C,MAAM+I,GAAG,GAAGF,SAAS,CAAC7I,CAAD,CAArB;;QACA,IAAG+I,GAAG,CAAC,CAAD,CAAH,KAAWjG,GAAd,EAAkB;UAChB,KAAI,IAAIwF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGS,GAAG,CAAClI,MAAvB,EAA+ByH,CAAC,EAAhC,EAAmC;YACjC,IAAGS,GAAG,CAACT,CAAD,CAAH,KAAWpG,GAAG,CAACO,GAAG,GAAC6F,CAAL,CAAjB,EAA0B,SAASF,KAAT;UAC3B;;UACD,OAAOW,GAAG,CAAClI,MAAX;QACD;MACF;;MACD,OAAO,CAAP;IACD,CA/jBI;IAgkBL+C,mBAAmB,EAAE,UAASd,GAAT,EAAcZ,GAAd,EAAmBO,GAAnB,EAAuB;MAC1C,MAAM;QAACZ;MAAD,IAAqB,KAAKhC,OAAhC;MACA,MAAMiF,qBAAqB,GAAGjD,gBAAgB,CAAChB,MAA/C;;MACAuH,KAAK,EAAE,KAAI,IAAIpI,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG8E,qBAAnB,EAA0C9E,CAAC,EAA3C,EAA8C;QACnD,MAAMgJ,EAAE,GAAGnH,gBAAgB,CAAC7B,CAAD,CAA3B;QACA,MAAMiJ,QAAQ,GAAGD,EAAE,CAACnI,MAApB;;QACA,IAAGmI,EAAE,CAAC,CAAD,CAAF,KAAUlG,GAAb,EAAiB;UACf;QACD;;QACD,KAAI,IAAIwF,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGW,QAAnB,EAA6BX,CAAC,EAA9B,EAAiC;UAC/B,IAAGU,EAAE,CAACV,CAAD,CAAF,KAAUpG,GAAG,CAACO,GAAG,GAAC6F,CAAL,CAAhB,EAAwB;YACtB,SAASF,KAAT;UACD;QACF;;QACD,OAAOY,EAAE,CAACnI,MAAV;MACD;;MACD,OAAO,CAAP;IACD,CAjlBI;IAklBLoC,UAAU,EAAE,UAASf,GAAT,EAAcO,GAAd,EAAmBK,GAAnB,EAAuB;MACjC,MAAM;QAAC1C;MAAD,IAAW,KAAKP,OAAtB;MACA,IAAGO,MAAM,KAAK,IAAd,EAAoB,OAAO,KAAP;MACpB,MAAMsG,CAAC,GAAGtG,MAAM,CAACS,MAAjB;;MACA,IAAGT,MAAM,CAAC,CAAD,CAAN,KAAc0C,GAAjB,EAAqB;QACnB,KAAI,IAAI9C,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG0G,CAAnB,EAAsB1G,CAAC,EAAvB,EAA0B;UACxB,IAAGI,MAAM,CAACJ,CAAD,CAAN,KAAckC,GAAG,CAACO,GAAG,GAACzC,CAAL,CAApB,EAA4B;YAC1B,OAAO,KAAP;UACD;QACF;;QACD,OAAO,IAAP;MACD;;MACD,OAAO,KAAP;IACD,CA/lBI;IAgmBLkD,SAAS,EAAE,UAAShB,GAAT,EAAcO,GAAd,EAAkB;MAC3B,MAAM;QAACpC;MAAD,IAAU,KAAKR,OAArB;MACA,IAAGQ,KAAK,KAAK,IAAb,EAAmB,OAAO,KAAP;MACnB,MAAMqG,CAAC,GAAGrG,KAAK,CAACQ,MAAhB;;MACA,KAAI,IAAIb,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG0G,CAAnB,EAAsB1G,CAAC,EAAvB,EAA0B;QACxB,IAAGK,KAAK,CAACL,CAAD,CAAL,KAAakC,GAAG,CAACO,GAAG,GAACzC,CAAL,CAAnB,EAA2B;UACzB,OAAO,KAAP;QACD;MACF;;MACD,OAAO,IAAP;IACD,CA1mBI;IA2mBL6C,6BAA6B,EAAE,UAASX,GAAT,EAAcO,GAAd,EAAkB;MAC/C,MAAM;QAAEtC;MAAF,IAAe,KAAKN,OAA1B,CAD+C,CAE/C;MACA;MACA;;MACA,MAAMqJ,GAAG,GAAG,CACV;MACAhK,MAAM,CAACC,IAAP,CAAY,MAAZ,EAAoBgB,QAApB,CAFU,EAGVjB,MAAM,CAACC,IAAP,CAAY,IAAZ,EAAkBgB,QAAlB,CAHU,EAIVjB,MAAM,CAACC,IAAP,CAAY,IAAZ,EAAkBgB,QAAlB,CAJU,CAAZ;;MAMAgJ,IAAI,EAAE,KAAI,IAAInJ,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAGkJ,GAAG,CAACrI,MAAvB,EAA+Bb,CAAC,EAAhC,EAAmC;QACvC,MAAM0G,CAAC,GAAGwC,GAAG,CAAClJ,CAAD,CAAH,CAAOa,MAAjB;;QACA,KAAI,IAAIyH,CAAC,GAAG,CAAZ,EAAeA,CAAC,GAAG5B,CAAnB,EAAsB4B,CAAC,EAAvB,EAA0B;UACxB,IAAGY,GAAG,CAAClJ,CAAD,CAAH,CAAOsI,CAAP,MAAcpG,GAAG,CAACO,GAAG,GAAG6F,CAAP,CAApB,EAA8B;YAC5B,SAASa,IAAT;UACD;QACF;;QACD,KAAKtJ,OAAL,CAAagC,gBAAb,CAA8Bb,IAA9B,CAAmCkI,GAAG,CAAClJ,CAAD,CAAtC;QACA,KAAKF,KAAL,CAAWU,wBAAX,GAAsC0I,GAAG,CAAClJ,CAAD,CAAH,CAAOa,MAA7C;QACA,OAAOqI,GAAG,CAAClJ,CAAD,CAAH,CAAOa,MAAd;MACD;;MACD,OAAO,CAAP;IACD,CAloBI;IAmoBLkD,OAAO,EAAE,UAASqF,GAAT,EAAa;MACpB,MAAM;QAACjJ,QAAD;QAAWmB,GAAX;QAAgB+H;MAAhB,IAA2C,KAAKxJ,OAAtD;MACA,MAAMiE,GAAG,GAAG,OAAOsF,GAAP,KAAe,QAAf,GAA0B,IAAIE,KAAJ,CAAUF,GAAV,CAA1B,GAA2CA,GAAvD;;MACA,IAAGC,uBAAH,EAA2B;QACzB,KAAKvJ,KAAL,CAAWyG,cAAX,GAA4B,IAA5B;;QACA,IAAG,KAAK1G,OAAL,CAAa0J,OAAb,KAAyBpH,SAA5B,EAAsC;UACpC,KAAKtC,OAAL,CAAa0J,OAAb,CAAqBzF,GAArB,EAA0BxC,GAAG,GAAG,KAAKxB,KAAL,CAAWkC,SAAX,CAAqBnD,QAArB,CAA8BsB,QAA9B,CAAH,GAA6CgC,SAA1E;QACD,CAJwB,CAKzB;;;QACA,OAAOA,SAAP;MACD,CAPD,MAOK;QACH,OAAO2B,GAAP;MACD;IACF,CAhpBI;IAipBL0F,aAAa,EAAE,YAAU;MACvB,OAAO,EACL,GAAG,KAAKlK,IADH;QAELsG,OAAO,EAAE,KAAK/F,OAAL,CAAa+F;MAFjB,CAAP;IAID,CAtpBI;IAupBLqB,YAAY,EAAE,YAAU;MACtB,MAAM;QAACrB,OAAD;QAAUtE,GAAV;QAAenB;MAAf,IAA2B,KAAKN,OAAtC;MACA,OAAO,EACL,GAAG,KAAK2J,aAAL,EADE;QAELnD,KAAK,EAAE,KAAKvG,KAAL,CAAWuG,KAFb;QAGLoD,MAAM,EAAE7D,OAAO,KAAK,IAHf;QAIL8D,KAAK,EAAE,KAAK5J,KAAL,CAAWpB,MAAX,CAAkBmC,MAJpB;QAKLS,GAAG,EAAEA,GAAG,GAAG,KAAKxB,KAAL,CAAWkC,SAAX,CAAqBnD,QAArB,CAA8BsB,QAA9B,CAAH,GAA6CgC;MALhD,CAAP;IAOD,CAhqBI;IAiqBL+B,WAAW,EAAE,YAAU;MACrB,MAAM;QAAC0B;MAAD,IAAY,KAAK/F,OAAvB;MACA,MAAMgI,SAAS,GAAGhB,KAAK,CAACC,OAAN,CAAclB,OAAd,CAAlB;MACA,OAAO,EACL,GAAG,KAAKqB,YAAL,EADE;QAELpC,MAAM,EAAEgD,SAAS,KAAK,IAAd,GACLjC,OAAO,CAAC/E,MAAR,GAAiB,KAAKf,KAAL,CAAWpB,MAAX,CAAkBmC,MAAnC,GACC+E,OAAO,CAAC,KAAK9F,KAAL,CAAWpB,MAAX,CAAkBmC,MAAnB,CAAP,CAAkC+F,IADnC,GAEC,IAHI,GAKN,KAAK9G,KAAL,CAAWpB,MAAX,CAAkBmC,MAPf;QAQLP,OAAO,EAAE,KAAKR,KAAL,CAAW+D;MARf,CAAP;IAUD;EA9qBI,CAAP;AAgrBD,CA1rBD;;AA6rBA,SAAQzE,SAAR,EAAmBZ,QAAnB"},"metadata":{},"sourceType":"module"}